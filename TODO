== Sugar 2.0
-- To-do


Tools
=====

- `ctags-like` wrapper
- syntax highlighting for many editors

Syntax 
======

Incompatible changes
--------------------

[ ] Inline conditionals::

	currently

	```
	if CONDITION -> EXPRESSION (| CONDITION -> EXPRESSION)* | EXPRESSION
	```

	better would be 

	```
	CONDITION ? EXPRESSION : EXPRESSION
	```

	or 

	```
	EXPRESSION if CONDITION else EXPRESSION
	```

[X] Single-line conditionals::

	Single line conditionals have been removed

	```
	if   condition -> statements...
	elif condition -> statements...
	else           -> statements...
	```

	they are replaced with the normal form

	```
	if condition
		statements...
	elif condition
		statements...
	else
		statements...
	```

[X] Remove mandatory ends::

	At the end of the day, they don't serve any real purpose besides
	guarding against copy-paste.

[ ] Remove `@protocol` and `@singleton`::

	Not sure if they're really necessary, and they can be implemented
	with a `@class` and a `@shared`.


Syntax fixes
------------

[X] Dict keys::

	Expressions as dict keys need to be surrounded by parens, and 
	this inlcudes strings:

	```
	{("a"):"a"}
	```

	now parens are unncessary for string litterals:

	```
	{"a":"a"}
	```

New features
------------

### 0. Comments & documentations

[X] Comments in maps/lists::

	```
	{
		value: 1 # Some comment
		# value: 1 -- Value commented out
	}
	[
		value: 1 # Some comment
		# value: 1 -- Value commented out
	]
	```

### 0. Litterals

[X] Multi-line strings::

	```
	# Just like in Python
	"""asdsads
	asdsadas"""
	```

	```
	let a = """
	string on 
	multiple lines
	"""

	if c:
		let b = """
		string
		on 
		multiple
		lines
		"""
	```

[ ] String format/interpolation::

	We could use inline expressions

	```
	f"{some code}, {1 + 2}" 
	```

	Or format with positional arguments

	```
	"{0:d} {1:d}" % ()     # Uses the local scope
	"{0:d} {1:d}" % {dict} # Uses the given dict as a scope
	```

[X] Tuples::

	```
	(1,2,3,4)
	```

	```
	() 
	(1)
	(1, 2, 3)
	() 
	(1) 
	```

[X] Named tuples::

	```
	(a=1, b=2, c=3, 4)
	```


[ ] Map setdefault/assign if not null::

	a[1] ?= 1.0
	
	equals to

	if not isDefined(a[1]) -> a[1] = 1.0

[ ] Map implicit keys::

	```
	let a = 10
	let d = {a}
	assert (cmp( d, {a:10} ) == 0)
	```

[ ] Primitive alternative constructors::

	```
	[1,2,3,4]@AltClass
	```

[ ̧] Hex/Bit notation::

	```
	0xFF
	0b011010101
	```

### Operations

[ ] Absence of value::

	```
	var a = (asdas sadasd ? {})
	```

[ ] Chaining::

	```
	d3 selection () 
		a ()          # a is called on the result of d3 selection ()
		b ()          # b is called on the result of ()

	d3 selection () :
		a ()          # both a and b are with the same result
		b ()
	```

	```
	value:
		a ()
		b ()
	```
	
	is equal to

	```
	value a () b ()
	```

	and you can also affect that

	```
	var r = value:
		a ()
		b ()
	```

	and chain it

	```
	var r = value:
		a ()
		b () :
			c ()
	```
	
	which equals to

	```
	var r = value ()
	r a ()
	var t = r b ()
	t c ()
	```


[ ] Pattern matching::

	as a keyword

	```
	match getResult()
		<string>
			"A string"
		<number> and _ > 10	
			"A number"
		<number> and _ < 0	
			"A negative number"
		*
			"Rest"
	end
	```

	as a specific chain type

	```
	expression |
		predicate
			block
		predicate → line
		<type>
	```

	alternate syntax:

	```
	match value as f
		case 1.0
			code
		case f like (_, _, _)
			code
		else
			code
	end
	```

### Declaration/Invocation

[X] Default arguments::

	```
	@function f a=0, b=1, c=2
	@end
	```


[ ] Named arguments::
	
	```
	@function i a, b, rest...
	@end
	```

	```
	@function i a, b, rest..., options=...
	@end
	```

[ ] Function pipes::

	The pipe `|` syntax can be used to chain functions in an expression. The first expression can contain
	no argument, but the other expressions must contain the `_` variable to be valid.

	```
	a () | b (1,2,_) | c(2,3,_)
	```

	```
	e(2,3,(b(1,2,a())))
	```

### Semantics

[ ] Generators::

	```
	var f = {
		for a in 0..100
			yield a
		end
	}
	```

### Structure

[ ] Decorators::

	```
	@function decorate f, a
		f __value = a
		return f
	@end

	@function pouet
	@decorate 10
	```

[X] Continue/break::

	```
	for a,b in 0..10
		if a == 5
			continue
		elif a > 7
			break
		end
	end
	```

### Sugar


[X] Automatic variables::

	```
	_  == arguments[0]
	_0 == arguments[0]
	_1 == arguments[1]
	_2 == arguments[2]
	```

[X] Implicit return::

	```
	{_| _ + 1}
	```

[X] Map/filter/... operators::

	```
	Filter  VALUE ::? PREDICATE
	Map     VALUE ::= EXTRACTOR
	Reduce  VALUE ::> EXTRACTOR
	ReduceR VALUE ::< EXTRACTOR
	```

[ ] List comprehensions / generators::

	```
	[x * 2 for x in COLLECTION if CONDITION]
	(x * 2 for x in COLLECTION if CONDITION)
	```

### Meta-information/meta-programming

[ ] Special variables::

	```
	__scope_name__ (ex: widgets.Widget.ensure)
	__scope__ 

	__module__
	__module_name__

	__class__
	__class_name__

	__method__
	__method_name__

	__function__
	__function_name__

	__class__
	__class_name__

	__line__
	__file__
	```


	and so in code


	```
	error ("{__scope_name__}:{__line__}: Error message")
	```


[ ] Macros::

	```
	@macro name( a, b, c )
		$a = pouet
		$b = pouet
		$c = pouet
	@end

	@function f
		@name(a,b,c)
	@end
	```

	will produce the code $a, $b, $c

	```
	@function f
		a = pouet
		b = pouet
		c = pouet
	@end
	```


[ ] Setdefault::

	```
	var a = {}
	a ["asdsa" ?= {}]["pouet"] = 10
	```


[ ] Bit-logic operator::
	
	```
	&&
	||
	!
	```

[ ] Infix operator::

	```
	e ~map extractor 
	```

	would be rewritten as

	```
	map (e, extractor)
	```

[ ] Infix functions::
 
 	@infix @function fold XXXX fold XXXX -> fold (XXX,XXX)


[ ] Streamlined mappings::

	```
	_ :: connector Project fold :: {_| (group[_ discipline [-1]] ?= []) push (_)}
	```

[ ] Design-by-contract Assert/pre/post/error::	

	```
	@function f
	@pre   expresssion error message
	@post  expression  error message
		body
	@where
		Test case
	@end
	```



# EOF

