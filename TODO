== Sugar 2.0
-- To-do


Tools
=====

- `ctags-like` wrapper
- syntax highlighting for many editors

Syntax 
======

Incompatible changes
--------------------

[X] Removed `@end` and `end`::

	These served as explicit guards against copy/paste, but in practice
	this cause the code to be more verbose without providing much benefit.

	```
	if condition
		statements‥
	else
		statements‥
	end
	``` 

	becomes

	```
	if condition
		statements‥
	else
		statements‥
	``` 

	and 

	```
	@function f
		statements‥
	@end
	``` 

	becomes

	```
	@function f
		statements‥
	``` 

[ ] Conditional expresssions::

	Conditional expressions were redundant with single-line conditionals

	```
	if CONDITION -> EXPRESSION (| CONDITION -> EXPRESSION)* | EXPRESSION
	```

	They are now unambiguously expressed as

	```
	EXPRESSION if CONDITION else EXPRESSION
	```

[X] Single-line conditionals::

	Single line conditionals have been removed

	```
	if   condition -> statements...
	elif condition -> statements...
	else           -> statements...
	```

	and replaced with the now more compact standard form

	```
	if condition
		statements...
	elif condition
		statements...
	else
		statements...
	```

[X] Embeds::

	Embeds previously were like

	```
	@embed JavaScript
	|...
	@end
	```
	
	and wow have the regular syntax


	```
	@embed JavaScript
		...
	```

Syntax fixes
------------

[X] Dict keys::

	Expressions as dict keys need to be surrounded by parens, and 
	this inlcudes strings:

	```
	{("a"):"a"}
	```

	now parens are unnecessary for string litterals:

	```
	{"a":"a"}
	```

New features
------------

0.0 Comments & documentations

[X] Comments in maps/lists::

	Comments are allowed within *lists*, *maps* and *tuples*.

	```
	{
		value: 1 # EOL line comment
		# value: 2 -- Value commented out
	}
	[
		1 # EOL comment
		# 2 Value commented out
	]
	(
		0
		value= 1 # Some comment
		# value: 1 -- Value commented out
	)
	```

0.0 Litterals

[X] Multi-line strings::

	```
	# Just like in Python
	"""asdsads
	asdsadas"""
	```

	```
	let a = """
	string on 
	multiple lines
	"""

	if c:
		let b = """
		string
		on 
		multiple
		lines
		"""
	```

[ ] String format/interpolation::

	We could use inline expressions

	```
	f"{some code}, {1 + 2}" 
	```

	Or format with positional arguments

	```
	"{0:d} {1:d}" % ()     # Uses the local scope
	"{0:d} {1:d}" % {dict} # Uses the given dict as a scope
	```

[X] Tuples::

	```
	(1,2,3,4)
	```

	```
	() 
	(1)
	(1, 2, 3)
	() 
	(1) 
	```

[X] Named tuples::

	```
	(a=1, b=2, c=3, 4)
	```


[ ] Map setdefault/assign if not null::

	a[1] ?= 1.0
	
	equals to

	if not isDefined(a[1]) -> a[1] = 1.0

[ ] Map implicit keys::

	```
	let a = 10
	let d = {a}
	assert (cmp( d, {a:10} ) == 0)
	```

[ ] Primitive alternative constructors::

	```
	[1,2,3,4]@AltClass
	```

[ ] Hex/Bit notation::

	```
	0xFF
	0b011010101
	```

0.0 Operations

[ ] Exitential operator::


	The *existential operator* `?` will  yield `Undefined` if any
	of resolution within the expression fails.

	```
	var a = (A B C D)? E
	```

	this typically gets converted into something like

	```
	var a = A B C D if (A and exists(A B) and exists(A B C) and exists(A B C D)) else E
	```

[ ] Chaining::

	```
	d3 selection () 
		a ()          # a is called on the result of d3 selection ()
		b ()          # b is called on the result of ()

	d3 selection () :
		a ()          # both a and b are with the same result
		b ()
	```

	```
	value:
		a ()
		b ()
	```
	
	is equal to

	```
	value a () b ()
	```

	and you can also affect that

	```
	var r = value:
		a ()
		b ()
	```

	and chain it

	```
	var r = value:
		a ()
		b () :
			c ()
	```
	
	which equals to

	```
	var r = value ()
	r a ()
	var t = r b ()
	t c ()
	```

[ ] Pattern matching::

	as a keyword

	```
	match getResult()
		<string>
			"A string"
		<number> and _ > 10	
			"A number"
		<number> and _ < 0	
			"A negative number"
		*
			"Rest"
	end
	```

	as a specific chain type

	```
	expression |
		predicate
			block
		predicate → line
		<type>
	```

	alternate syntax:

	```
	match value as f
		case 1.0
			code
		case f like (_, _, _)
			code
		else
			code
	end
	```

0.0 Declaration/Invocation

[X] Default arguments::

	```
	@function f a=0, b=1, c=2
	@end
	```

[ ] Named arguments::
	
	```
	@function i a, b, rest...
	@end
	```

	```
	@function i a, b, rest..., options=...
	@end
	```

[ ] Function pipes::

	The pipe `|` syntax can be used to chain functions in an expression. The first expression can contain
	no argument, but the other expressions must contain the `_` variable to be valid.

	```
	a () | b (1,2,_) | c(2,3,_)
	```

	```
	e(2,3,(b(1,2,a())))
	```

0.0 Semantics

[ ] Generators::

	```
	var f = {
		for a in 0..100
			yield a
		end
	}
	```

0.0 Structure

[ ] Singleton::

	declares a singleton object that will be initialized during module initialization. 

	```
	@singleton NAME: PARENT
		@property ‥
		@constructor ‥
		@method ‥
	```

[ ] Trait::

	Traits are a collection of properties and methods that can be mixed-in with classes. 
	Classes retain the primary mode of inheritence, and traits will be merged in their
	order of declaration.

	```
	@trait A: PARENT
		@property ‥
		@constructor ‥
		@method ‥
	

	@class C0
		pass
	
	# Declares C1 as inheriting from C0 and merging trait A
	@class C1: C0,A
		pass

	# Declares C1 as merging trait A with the default Object class
	@class C1: A
		pass
		
	```



[ ] Decorators::

	```
	@function decorate f, a
		f __value = a
		return f
	@end

	@function pouet
	@decorate 10
	```

[X] Continue/break::

	```
	for a,b in 0..10
		if a == 5
			continue
		elif a > 7
			break
		end
	end
	```

0.0 Syntax Sugar

[X] Automatic variables::

	```
	_  == arguments[0]
	_0 == arguments[0]
	_1 == arguments[1]
	_2 == arguments[2]
	```

[X] Implicit return::

	```
	{_| _ + 1}
	```

[X] Map/filter/... operators::

	```
	Filter  VALUE ::? PREDICATE
	Map     VALUE ::= EXTRACTOR
	Reduce  VALUE ::> EXTRACTOR
	ReduceR VALUE ::< EXTRACTOR
	```

[ ] List comprehensions / generators::

	```
	[x * 2 for x in COLLECTION if CONDITION]
	(x * 2 for x in COLLECTION if CONDITION)
	```

0.0 Meta-information/meta-programming

[ ] Special variables::

	```
	__scope_name__ (ex: widgets.Widget.ensure)
	__scope__ 

	__module__
	__module_name__

	__class__
	__class_name__

	__method__
	__method_name__

	__function__
	__function_name__

	__class__
	__class_name__

	__line__
	__file__
	```


	and so in code


	```
	error ("{__scope_name__}:{__line__}: Error message")
	```


[ ] Macros::

	```
	@macro name( a, b, c )
		$a = pouet
		$b = pouet
		$c = pouet
	@end

	@function f
		@name(a,b,c)
	@end
	```

	will produce the code $a, $b, $c

	```
	@function f
		a = pouet
		b = pouet
		c = pouet
	@end
	```


[ ] Setdefault::

	```
	var a = {}
	a ["asdsa" ?= {}]["pouet"] = 10
	```


[ ] Bit-logic operator::
	
	```
	&&
	||
	!
	```

[ ] Infix operator::

	```
	e ~map extractor 
	```

	would be rewritten as

	```
	map (e, extractor)
	```

[ ] Infix functions::
 
 	@infix @function fold XXXX fold XXXX -> fold (XXX,XXX)


[ ] Streamlined mappings::

	```
	_ :: connector Project fold :: {_| (group[_ discipline [-1]] ?= []) push (_)}
	```

[ ] Design-by-contract Assert/pre/post/error::	

	```
	@function f
	@pre   expresssion error message
	@post  expression  error message
		body
	@where
		Test case
	@end
	```



# EOF

