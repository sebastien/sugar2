# -----------------------------------------------------------------------------
# Project           : Sugar2
# -----------------------------------------------------------------------------
# Author            : FFunction
# License           : BSD License
# -----------------------------------------------------------------------------
# Creation date     : 2016-11-01
# Last modification : 2016-11-01
# -----------------------------------------------------------------------------

@module sugar2.grammars.program
@import doIndent, doCheckIndent, doDedent, doBlockStart, doBlockLastSetLine, doBlockLastSetBody, doBlockLastIsLine from sugar2.grammars.helpers

# TODO: Break down the grammar in Expression, Structure and Types

@shared G

# -----------------------------------------------------------------------------
#
# GRAMMAR CONSTRUCTION FUNCTIONS
#
# -----------------------------------------------------------------------------
# NOTE: this group of functions are used to create rules within the grammar
# that share a similar structure. Another way would be to create new parsing
# elements for these, but it is simpler and more appropriate here to simply
# have "creator" patters for the elements.

@function declaration grammar, name, prefix
	var g = grammar ; var s = g symbols
	return g rule (name
		s CheckIndent
		prefix
		s NameType _as "name"
		g arule (
			g aword "="
			s Expression
		) optional () _as "value"
		s EOL
		s Documentation optional () _as "documentation"
	)
@end

@function function grammar, name, prefix, anonymous=False
	var g = grammar ; var s = grammar symbols
	# s Comment   zeroOrMore ()
	# s EmptyLine zeroOrMore ()
	#s EmptyLine zeroOrMore ()
	if anonymous
		return g rule (name
			s CheckIndent
			prefix _as "type"
			s NOTHING _as "name"
			g agroup (
				s EOL
				g arule (
					s ParameterList optional ()
					s EOL
				)
			) _as "parameters"
			s Documentation optional () _as "documentation"
			s Body _as "body"
			s OEnd
		)
	else
		return g rule (name
			s CheckIndent
			prefix     _as "type"
			s NameType _as "name"
			g agroup (
				s EOL
				g arule (
					s ParameterList optional ()
					s EOL
				)
			) _as "parameters"
			s Documentation optional () _as "documentation"
			s Body _as "body"
			s OEnd
		)
	end
@end

@function abstractFunction grammar, name, prefix
	var g = grammar ; var s = grammar symbols
	# NOTE: This is an interesting example of optimizing the grammar,
	# where we make sure that we prevent from trying too many parses
	# that will fail. By putting EOL first in the grammar, we'll ensure
	# the we won't try parameters if we have an EOL
	return g rule (name
		s CheckIndent
		s oabstract
		prefix _as "type"
		s NameType _as "name"
		g agroup (
			s EOL
			g arule (
				s ParameterList optional () _as "parameters"
				s EOL
			)
		)
		s Documentation optional () _as "documentation"
	)
@end

@function listOf rule, separator, grammar
| Creates a new list of the given rule, separated by the given separator
| in the given grammar
	return grammar arule (
		grammar arule ( rule, separator ) zeroOrMore ()
		rule
	)
@end

# -----------------------------------------------------------------------------
#
# LANGUAGE GRAMMAR
#
# -----------------------------------------------------------------------------

@function createProgramGrammar g=(new libparsing Grammar ("Sugar"))
	var s = g symbols
	g token     ("SPACE",            "[ ]+")
	g token     ("TABS",             "\t*")
	g token     ("EMPTY_LINES",      "([ \t]*\n)+")
	g token     ("INDENT",           "\t+")
	g token     ("COMMENT",          "[ \t]*\#[^\n]*")
	g token     ("EOL",              "[ ]*\n(\s*\n)*")
	# FIXME: Support 0xFFAAEE
	g token     ("NUMBER",           "\-?(0x)?[0-9]+(\.[0-9]+)?")
	g token     ("NAME",             "(\\\?)([\$_A-Za-z][_\w]*)")
	g token     ("KEY",              "[\$_\-A-Za-z][_\-\w]*")
	# TODO: Add "not in"
	g token     ("INFIX_OPERATOR",   "([\-\+\*\/\%]|\<=|\>=|\<|\>|==|\!=|\.\.|not\s+in\s+|in\s+|and\s+|or\s+|is\s+not\s+|is\s+|\*\*)")
	g token     ("PREFIX_OPERATOR",  "(not\s+|\-)")
	g token     ("NEW_OPERATOR",     "new\s+")
	g token     ("THROW_OPERATOR",   "(raise|throw)\s+")
	g token     ("ASSIGN_OPERATOR",  "[\?\*\+\-\/\%]?=")
	g token     ("SYMBOLIC",         "None|Undefined|Nothing|Timeout")
	g token     ("STRING_SQ",        "'(\\\\'|[^'\\n])*'")
	g token     ("STRING_DQ",        "\"(\\\\\"|[^\"\\n])*\"")
	g token     ("DOCSTRING",        "\|[^\n]*")
	g token     ("EMBED_LINE",       "\|([^\n]*)")
	g token     ("VERSION",          "[0-9]+(\.[0-9]+)?(\.[0-9]+)?[a-zA-Z_]*")
	g token     ("DOT_OR_SPACE",     "\.|[ \t]+")
	g token     ("ITERATOR",         "::[\?=\<]?")
	g token     ("ELLIPSIS",         "\.\.\.|‥")
	g token     ("BLOCKLINE",        "\-\>|→")
	# Punctuation
	g word      ("LP",               "(")
	g word      ("RP",               ")")
	g word      ("LB",               "{")
	g word      ("RB",               "}")
	g word      ("LSB",              "[")
	g word      ("RSB",              "]")
	g word      ("COMMA",            ",")
	g word      ("DOT",              ".")
	g word      ("COLON",            ":")
	g word      ("SEMICOLON",        ";")
	g word      ("PIPE",             "|")
	g word      ("EQUALS",           "=")
	g word      ("WILDCARD",         "*")
	g condition ("NOTHING")
	# Keywords
	g word      ("_var",             "var")
	g word      ("_let",             "let")
	g word      ("_if",              "if")
	g word      ("_elif",            "elif")
	g word      ("_else",            "else")
	g word      ("_for",             "for")
	g word      ("_while",           "while")
	g word      ("_end",             "end")
	g word      ("_in",              "in")
	g word      ("_from",            "from")
	g word      ("_as",              "as")
	g word      ("_try",             "try")
	g word      ("_catch",           "catch")
	g word      ("_finally",         "finally")
	g word      ("oabstract",        "@abstract")
	g word      ("oimport",          "@import")
	g word      ("omodule",          "@module")
	g word      ("otarget",          "@target")
	g word      ("orequires",        "@requires")
	g word      ("oversion",         "@version")
	# g word      ("olicense",         "@license")
	g word      ("ofunction",        "@function")
	g word      ("oclass",           "@class")
	g word      ("oproperty",        "@property")
	g word      ("oshared",          "@shared")
	g word      ("ooperation",       "@operation")
	g word      ("oconstructor",     "@constructor")
	g word      ("omethod",          "@method")
	g word      ("ogroup",           "@group")
	g word      ("oend",             "@end")
	g word      ("oembed",           "@embed")

	# Indentation
	g procedure ("Indent",           doIndent)
	g procedure ("Dedent",           doDedent)
	g rule      ("CheckIndent",      s TABS _as "tabs", g acondition (doCheckIndent))

	# Documentation & Comments
	# g rule      ("CommentLine",      s COMMENT,     s EOL)
	g rule      ("EmptyLines",       s EMPTY_LINES)
	g rule      ("DocumentationLine",s CheckIndent, s DOCSTRING, s EOL)
	g rule      ("Documentation",    s DocumentationLine oneOrMore ())

	# Basic types
	g group     ("String",           s STRING_SQ, s STRING_DQ)
	g rule      ("Expression")
	g group     ("Key",              s KEY, s NUMBER, s String, g arule( s LP, s Expression, s RP))
	g rule      ("KeyValue",         s Key, s COLON, s Expression)
	# TODO: Add support for comments within lines and blocks
	g rule      ("KeyValueList",     s KeyValue,   g arule (s COMMA, s KeyValue  ) zeroOrMore ())
	g rule      ("ExpressionList",   s Expression, g arule (s COMMA, s Expression) zeroOrMore ())
	g rule      ("ExpressionBlock",  s Indent,     g arule (s EOL,   s CheckIndent, s ExpressionList) oneOrMore (), s Dedent)
	g rule      ("KeyValueBlock",    s Indent,     g arule (s EOL,   s CheckIndent, s KeyValueList  ) oneOrMore (), s Dedent)
	g rule      ("Array",            s LSB, s ExpressionList optional () _as "head", s ExpressionBlock optional () _as "tail", g arule (s EOL, s CheckIndent) optional (), s RSB)
	g rule      ("Map",              s LB,  s KeyValueList   optional () _as "head", s KeyValueBlock   optional () _as "tail", g arule (s EOL, s CheckIndent) optional (), s RB)

	# Declarations
	g rule      ("TypeStructure",    g atoken "\<[^\>]*\>")
	g rule      ("Type",             g agroup (s NAME, s TypeStructure))
	g rule      ("NameType",         s NAME,     g arule (s COLON,  s Type)       optional   ())
	g rule      ("FQName",           s NAME,     g arule (s DOT_OR_SPACE,  s NAME)       zeroOrMore ())
	g rule      ("Parameter",        s NameType _as "name", g arule (s EQUALS, s Expression) optional   () _as "value")
	g rule      ("ParameterList",    s Parameter, g arule(s COMMA, s Parameter) zeroOrMore (), s ELLIPSIS optional ())
	g rule      ("SymbolList",       s NAME,      g arule(s COMMA, s NAME)      zeroOrMore (), s ELLIPSIS optional ())
	g rule      ("ArgumentsEmpty",   s LP, s RP)
	g rule      ("ArgumentsMany",    s LP, s ExpressionList optional () _as "line", s ExpressionBlock optional () _as "body", g agroup (s RP, g arule (s EOL optional (), s CheckIndent, s RP)))
	# Closures
	g rule      ("ClosureStatement")
	g rule      ("ClosureLine",       s EOL, s CheckIndent, s ClosureStatement)
	g rule      ("ClosureParameters", s ParameterList, s PIPE)
	g rule      ("InlineClosure",     s LB, s ClosureParameters optional(),  s ClosureStatement, s RB)
	g rule      ("BlockClosure",      s LB, s ClosureParameters optional (), s Indent, s ClosureLine zeroOrMore (), s Dedent, s EOL, s CheckIndent, s RB)
	g group     ("Closure",           s BlockClosure, s InlineClosure)

	# Expression prefixes
	g group     ("Literal",         s NUMBER, s SYMBOLIC, s String, s Array, s Map, s Closure)
	# We only allow dots to chain notations
	g rule      ("Decomposition",    s DOT_OR_SPACE, s NAME, g arule (s DOT, s NAME) zeroOrMore ())
	# FIXME: Decomposition and resolution should be the same, no?
	#g rule      ("Resolution",       s SPACE, s NAME,  g rule ("ResolutionTail", s SPACE, s NAME) zeroOrMore ())
	g rule      ("ComputationInfix", s INFIX_OPERATOR, s Expression)
	g rule      ("Access",           s LSB,            s Expression, s RSB)
	g rule      ("Slice",            s LSB,            s Expression optional (), s COLON, s Expression optional (), s RSB)
	g group     ("Invocation",       g arule (s SPACE, s Literal), s ArgumentsEmpty, s ArgumentsMany )
	g rule      ("Parentheses",      s LP,    s Expression, s RP)
	g group     ("Prefixes"
		s Literal
		g rule  ("Exception",        s THROW_OPERATOR, s Expression _as "expression")
		g rule  ("Instanciation",    s NEW_OPERATOR,   g agroup (s FQName, s Parentheses) _as "target", s Invocation _as "params")
		g rule  ("ComputationPrefix",s PREFIX_OPERATOR, s Expression)
		s NAME
		s Parentheses
	)
	g group     ("Suffixes", s ComputationInfix, s Decomposition, s Access, s Slice, s Invocation)
	s Expression set (s Prefixes, s Suffixes zeroOrMore ())

	# Operations
	g rule      ("Assignable", s NAME, g agroup(s Decomposition, s Access, s Slice, s Invocation) zeroOrMore ())
	g rule      ("Allocation", g agroup (s _var, s _let), s SPACE, s SymbolList _as "symbols", g arule (s PIPE, s NAME) optional () _as "rest", g arule (s EQUALS, s Expression) optional () _as "value")
	g rule      ("Assignment"
		g arule (s Assignable, s COMMA) zeroOrMore () _as "before"
		s Assignable _as "main"
		g arule (s PIPE, s Assignable) optional () _as "rest"
		g arule (s ASSIGN_OPERATOR, s Expression)  _as "op"
	)
	g rule       ("Termination", g aword "return", s Expression optional ())
	g rule       ("IterationLine", s Expression, s ITERATOR, s Expression)

	# Blocks
	g group     ("Block")
	g group     ("Code")
	g rule      ("Comment",          s COMMENT, s EOL)
	g group     ("Statement",   s Comment, s Block, s Allocation, s Assignment, s Termination, s IterationLine, s Expression)
	g rule      ("Statements",  s Statement, g arule (s SEMICOLON, s Statement) zeroOrMore ())
	g rule      ("Line",             s CheckIndent, s Statements optional (), s COMMENT optional (), s EOL)
	g rule      ("End",              s CheckIndent, s _end, s EOL)
	# NOTE: We use procedures and condition to support single line and block versions of the blocks
	g procedure ("BlockStart",       doBlockStart)
	# FIXME: This is EOL is causing problems with comments straight after a single-line if
	# | if (not context) and (not isList(context)) and (not isMap(context)) -> context = {}
	# | # Support key-value pairs as well
	g rule      ("BlockLine",        s BLOCKLINE, s Statements _as "body", g agroup (s COMMENT, s EOL) zeroOrMore ())
	g rule      ("BlockBody",        s EOL, s Indent, s Code zeroOrMore () _as "body", s Dedent)
	g group     ("BlockEnd",         s End optional ())
	# disableMemoize ()
	# NOTE: If has no checkindednt to support for {assd|if -> asdsadas ... }
	# FIXME: Leaving the s CheckIndent optional () here puts the parser in an infinite loop...
	# g rule      ("IfBranch",         s CheckIndent optional (), s _if,    s Expression, g agroup (s BlockBody, s BlockLine))

	g rule      ("IfLine" ,    s CheckIndent, s _if,    s Expression _as "condition", g agroup (s BlockLine) _as "body")
	g rule      ("ElifLine" ,  s CheckIndent, s _elif,  s Expression _as "condition", g agroup (s BlockLine) _as "body")
	g rule      ("ElseLine" ,  s CheckIndent, s _else,  g agroup (s BlockLine) _as "body")

	g rule      ("IfBlock" ,         s CheckIndent, s _if,    s Expression _as "condition", g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("ElifBlock",       s CheckIndent, s _elif,  s Expression _as "condition", g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("ElseBlock",       s CheckIndent, s _else,                                g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("WhileBlock",      s CheckIndent, s _while, s Expression _as "condition", g agroup (s BlockBody, s BlockLine) _as "body")

	g rule      ("TryBlock",        s CheckIndent, s _try,                                 g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("FinallyBlock",    s CheckIndent, s _finally,                             g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("CatchBlock",      s CheckIndent, s _catch, s NameType optional () _as "param", g agroup (s BlockBody, s BlockLine) _as "body")
	g rule      ("ForBlock",        s CheckIndent, s _for,   s ParameterList _as "params", s _in, s Expression _as "expr", g agroup (s BlockBody, s BlockLine) _as "body")


	g rule      ("ConditionalLine",  s IfLine _as "if", s ElifLine zeroOrMore () _as "elif", s ElseLine optional () _as "else")
	g rule      ("ConditionalBlock", s BlockStart, s IfBlock    _as "if",    s ElifBlock zeroOrMore () _as "elif", s ElseBlock optional () _as "else", s BlockEnd)
	g group     ("Conditional",      s ConditionalLine, s ConditionalBlock)

	g rule      ("Try",              s BlockStart, s TryBlock   _as "try",   s CatchBlock optional  () _as "catch", s FinallyBlock optional () _as "finally", s BlockEnd)
	g rule      ("Repetition",       s BlockStart, s WhileBlock _as "while", s BlockEnd)
	g rule      ("Iteration",        s BlockStart, s ForBlock   _as "for",   s BlockEnd)
	s Block set (                    s Conditional, s Repetition, s Iteration, s Try)
	s Code  set (                    s Comment, s Block, s Line)

	# Program
	g rule      ("OEnd",             s CheckIndent, s oend,      s EOL)
	g rule      ("Body",             s Indent, s Code zeroOrMore () _as "code", s Dedent)
	s ClosureStatement set (s Statements)
	declaration      (g, "ClassAttribute",    s oshared)
	declaration      (g, "ModuleAttribute",   s oshared)
	declaration      (g, "Attribute",         s oproperty)
	# abstractFunction (g, "AbstractFunction",  s ofunction)
	abstractFunction (g, "AbstractMethod",    s omethod)
	abstractFunction (g, "AbstractOperation", s ooperation)
	function         (g, "Function",          s ofunction)
	function         (g, "Constructor",       s oconstructor, True)
	function         (g, "Method",            s omethod)
	function         (g, "Operation",         s ooperation)
	# NOTE: Group and Rule are already element names
	g rule  ("CGroup")
	# NOTE: Operations and Abstract Operations are also supported in Methods, but this should be deprecated
	g group ("Methods", s Operation, s AbstractOperation, s Method, s AbstractMethod, s AbstractMethod, s CGroup, s Comment)
	s CGroup set (s CheckIndent, s ogroup, s NAME _as "name",     s EOL, s Documentation optional (), s Indent, s Methods zeroOrMore () _as "methods", s Dedent, s OEnd)
	g rule  ("EmbedLine",  s CheckIndent, s EMBED_LINE, s EOL)
	g rule  ("Embed",      s CheckIndent, s oembed, s NAME optional () _as "language", s EOL, s EmbedLine zeroOrMore () _as "body", s OEnd)
	s Block add (s Embed)
	g rule  ("Class"
		s oabstract optional ()
		s oclass
		s NAME _as "name"
		g arule (s COLON, listOf (s FQName, s COMMA, g)) optional () _as "inherits"
		s EOL
		s Documentation optional () _as "documentation"
		s Indent
		g agroup (s ClassAttribute, s Attribute, s Operation, s AbstractOperation, s Constructor, s Methods) zeroOrMore () _as "body"
		s Dedent
		g aword "@end"
	)
	g rule  ("ModuleAnnotation",      s omodule,   s FQName, s EOL)
	g rule  ("VersionAnnotation",     s oversion,  s VERSION, s EOL)
	g rule  ("RequiresAnnotation",    s orequires, s FQName, g arule (s COMMA, s FQName) zeroOrMore (), s EOL)
	g rule  ("TargetAnnotation",      s otarget,   s NAME oneOrMore (), s EOL)
	g rule  ("ImportSingleSymbol",    s oimport,   s NAME,     s _from, s FQName, g arule (s _as, s NAME) optional (), s EOL)
	g rule  ("ImportSingleFQSymbol",  s oimport,   s FQName,   g arule (s _as,    s NAME) optional (), s EOL)
	g rule  ("ImportMultipleSymbols", s oimport,   s NAME,     g arule (s COMMA,  s NAME) zeroOrMore (), s _from, s FQName, s EOL)
	g rule  ("ImportAllSymbols",      s oimport,   s WILDCARD, s _from, s FQName, s EOL)
	g group ("ImportOperation"
		s ImportAllSymbols
		s ImportMultipleSymbols
		s ImportSingleFQSymbol
		s ImportSingleSymbol
	)
	g rule ("ModuleDeclaration"
		s EmptyLines         zeroOrMore ()
		s Comment            zeroOrMore ()
		s ModuleAnnotation   optional   ()
		s VersionAnnotation  optional   ()
		s Documentation      optional   () _as "documentation"
		s RequiresAnnotation optional   ()
		s TargetAnnotation   optional   ()
		s ImportOperation    zeroOrMore ()
	)
	g group     ("Structure",          s EmptyLines, s Comment, s ModuleAttribute, s Function, s Class)
	g rule      ("Module",             s ModuleDeclaration,  s Structure zeroOrMore (), s Code zeroOrMore ())

	g skip      = g agroup (s SPACE, s COMMENT)

	# NOTE: Right now, MODULE does not work, we're using Code instea
	g axiom     = s Module

	return g
@end

# EOF - vim: ts=4 sw=4 noet
