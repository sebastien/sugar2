# -----------------------------------------------------------------------------
# Project           : Sugar2
# -----------------------------------------------------------------------------
# Author            : FFunction
# License           : BSD License
# -----------------------------------------------------------------------------
# Creation date     : 2016-11-01
# Last modification : 2016-11-01
# -----------------------------------------------------------------------------

@module  sugar2.writer
@import  libparsing
@import  interfaces           from lambdafactory
@import  Factory              from lambdafactory.modelbase
@import  lambdafactory.passes as passes
@import  lambdafactory.resolution as resolution

@shared F = new Factory ()

# -----------------------------------------------------------------------------
#
# INTERFACE TO LAMBDA FACTORY
#
# -----------------------------------------------------------------------------

@class LambdaFactoryBuilder: libparsing.Processor
| Converts a parse tree into a Lambda Factory program model, which can then
| be translated to one of Lambda Factory's target language.
|
| Each `onXXX` should return a corresponding LambdaFactory model, or a list
| of them. The basic structure for a `onXXX` (where `XXX` is the rule name) is
| like that:
|
| ```
| @method on<RuleName> element, data, context
|     # element is the `parsing.Element` subclass
|     # data is the raw data returned by the element `process` method
|     # context is the `parsing.ParsingContext` instance
|     #
|     # Here, we retrieve the part of the data for the "code" rule. The
|     # code_data will contain one or more (element, data, context) triples.
|     var code_data = element resolve ("code", data)
|     # And we apply the rules for the specific elements, and retrieve a
|     # lambda factory object
|     var code      = on (code_data)
|     # We should then do something with the object...
|     return code
| @end
| ```

	@shared OPERATORS = [
		["or"]
		["and"]
		[">" , ">=" , "<" , "<=" , "!=" , "==" , "is" , "is not" , "in" , "not in"]
		[".."]
		["+"  , "-"]
		["not"]
		["/"  , "*"  , "%" , "//" ]
		["/=", "*=", "%=", "+=" , "-="]
	]

	@property module
	@property path      = None
	@property scopes    = []
	@property processes = []

	@constructor grammar, path=None
		super (grammar)
		self path = path
		program = F createProgram ()
		scopes append (program)
		program setFactory (F)
	@end

	@method access value, keys...
		for k in keys
			if value
				value = value[k]
			else
				return value
			end
		end
		return value
	@end

	@method process match
		var res = super process (match)
		if isinstance (res, interfaces IElement)
			pass
			# res setOffset (match start, parsingResult end)
			# if self path
			# 	res setSourcePath (self path)
			# end
		end
		return res
	@end

	@method getDefaultModuleName
		# FIXME: This should be done within LambdaFactory, not here
		if path
			return path split "/" [-1] split "." [0] replace ("-", "_")
		else
			return "__current__"
		end
	@end

	@method normalizeOperator operator
		# FIXME: In sugar
		# operator = "" join ((_ strip () for _ in operator split () if _ strip ()))
		@embed Python
		|operator = operator.replace("\t"," ").replace("\n"," ")
		|operator = " ".join((_.strip() for _ in operator.split() if _.strip()))
		@end
		return operator
	@end

	@method getOperatorPriority operator
		var i = 0
		for line in OPERATORS
			if operator in line
				return i
			end
			i += 1
		end
		raise (new Exception ("Unknown operator: " + str(operator)))
	@end

	@method _var name=None, context=(self context)
	| Lists the variables defined in the given context or gets the
	| variable with the given name.
		if not name
			return context getVariables () keys ()
		else
			return context getVariables () get (name)
		end
	@end

	@method _bind referanceable
	| Assigns the given referenceable to the current scope
		scopes[-1] setSlot (referanceable getName (), referanceable)
	@end

	@method filterNull result
	| Returns only the elements of result that have a value
		@embed Python
		|return filter(lambda _:_, result)
		@end
	@end

	@method _tryGet list, index, default
	| Tries to get the `index`th element of `list` or returns `default`
		if list and len(list) > index
			return list[index]
		else
			return None
		end
	@end

	@method _setCode element, code
		code = code or []
		for line in (code or [])
			if not (isinstance(line, tuple) or isinstance(line, list))
				line = [line]
			end
			for statement in (line or [])
				if isinstance (statement, interfaces IOperation)
					element addOperation (statement)
				elif isinstance(line, tuple) or isinstance(line, list)
					_setCode (element, line)
				else
					assert (False, "Code element type not supported: {0}" format (repr(statement)))
				end
			end
		end
		return element
	@end

	# =========================================================================
	# STRUCTURE
	# =========================================================================

	@method onModule match
		let declaration = process (match[0])

		# We parse the annotations
		let annotations = {}
		for _ in declaration
			if isinstance (_, interfaces IAnnotation)
				annotations[_ getName ()] = _ getContent ()
			end
		end

		# We create the module
		# TODO: Support module dosctring from annotation
		let module = F createModule (annotations get "module" or getDefaultModuleName())

		# A module is a scope, so we add it to the scopes stack
		scopes append (module)

		# We take care of the version number
		if annotations get "version"
			_bind (F _moduleattr ("VERSION", None, F _string (annotations get "version")))
		end

		let structure   = process (match[1])
		let code        = process (match[2])

		# We create the init function
		var init_function  = F createFunction (F ModuleInit)
		_setCode (init_function, code)
		_bind    (init_function)

		# We pop the scopes as we're done with the module
		scopes pop ()

		return module
	@end

	@method onModuleAnnotation match
		var ref = process(match[1])
		return F annotation ("module", ref getReferenceName ())
	@end

	@method onVersionAnnotation match
		return F annotation ("version", match[1] group ())
	@end

	@method onClass element, data, context
		# We start by binding the scope
		var variables   = element variables (data)
		var name        = getElements (on(variables["name"]))
		var res         = F createClass (name[0] getName (), name[1:])
		scopes append (res)
		var is_abstract = on(data[0])
		var inherits    = on(variables["inherits"])
		var doc         = element resolve ("documentation", data)
		on(variables["body"])
		res setDocumentation (doc and on(doc))
		res setAbstract      (is_abstract and True)
		scopes pop ()
		_bind (res)
		return res
	@end

	@method onAttribute element, data, context
		var v     = element variables (data)
		var name  = getElements (on(v["name"]))
		var value = getElements (on(v["value"]))
		var doc   = getElements (on(v["documentation"]))
		# FIXME: Value is reference, but it should be a resolution if it's a reference, no?
		var res   = F _attr (name[0] getReferenceName (), None, value and value[0])
		res setDocumentation (doc and doc[0])
		_bind (res)
		return res
	@end

	@method onClassAttribute element, data, context
		let name_type = process (match[2])
		let value     = _tryGet (process (match[3]), 1, None)
		let doc       = process (match[5])
		var res       = F _classattr (name_type[0] getReferenceName (), None, value and value[0])
		res setDocumentation (doc and doc[0])
		_bind (res)
		return res
	@end

	@method onModuleAttribute match
		let name_type = process (match[2])
		let value     = _tryGet (process (match[3]), 1, None)
		let doc       = process (match[5])
		var res       = F _moduleattr (name_type[0] getReferenceName(), None, value)
		res setDocumentation (doc and doc[0])
		_bind (res)
		return res
	@end

	@method onCGroup element, data, context
		var data_name    = element resolve ("name",    data)
		var data_methods = element resolve ("methods", data) or []
		var methods      = []
		var group_annotation = F annotation ("as", on (data_name) getReferenceName ())
		for m in (on(data_methods) or [])
			m addAnnotation (group_annotation)
			methods append (m)
		end
		return methods
	@end

	@method _createCallable factory, match
		let name_type  = process (match[2])
		let params     = process (match[3])
		let doc        = process (match[4])
		let body       = process (match[5])
		var fun        = None
		if name_type
			fun    = factory (name_type[0] getReferenceName (), params)
		else
			fun    = factory (params)
		end
		fun setDocumentation (doc)
		scopes append (fun)
		_setCode (fun, body)
		scopes pop ()
		_bind    (fun)
		return fun
	@end

	@method onOperation match
		return _createCallable (F createClassMethod, match)
	@end

	@method onAbstractOperation match
		var res = _createCallable (F createClassMethod, match)
		res setAbstract (True)
		return res
	@end

	@method onMethod match
		return _createCallable (F createMethod, match)
	@end

	@method onConstructor match
		return _createCallable (F createConstructor, match)
	@end

	@method onAbstractMethod match
		return _createCallable (F createAbstractMethod, match)
	@end

	@method onFunction match
		return _createCallable (F createFunction, match)
	@end

	# @method onAbstractFunction element, data, context
	# 	return _createCallable (F createAbstractFunction, element, data, context)
	# @end

	@method onClosureParameters match
		return process(match[0])
	@end

	@method onClosureBody match
		return process(match[0])
	@end

	@method onClosureStatement match
		return process(match[0])
	@end

	@method onClosure match
		let params = process (match[1])
		let line   = [process (match[2])]
		var res    = F createClosure (params)
		_setCode( res, line)
		return res
	@end

	# =========================================================================
	# CODE
	# =========================================================================

	@method onBody match
		return process (match[1])
	@end

	@method onCode match
		let content = process(match[0])
		return content
	@end

	@method onLine match
		let comment    = self process (match[2])
		let statements = self process (match[1])
		return statements
	@end

	@method onStatements match
		var res        = [process (match[0])]
		let tail       = process (match[1])
		for _ in tail
			res append (_[1])
		end
		return res
	@end

	@method onStatement match
	| Returns an `Element` or a list of `[Element]`. Typically these elements
	| would be Comments, Blocks or Operations.
		return process (match[0])
	@end

	# =========================================================================
	# CONTROL STRUCTURES
	# =========================================================================

	@method onConditional element, data, context
		var data_if    = data[1]
		var data_elifs = data[2]
		var data_else  = data[3]
		var _if        = on (data_if)
		var _elifs     = on (data_elifs) or []
		var _else      = on (data_else)
		var res        = F select ()
		res addRule (F matchProcess (_if[0], _if[1]))
		for _ in _elifs
			res addRule (F matchProcess (_[0], _[1]))
		end
		if _else
			# FIXME: Should be "res setFallback"
			res addRule (F matchProcess (F _ref "True", _else[0]))
		end
		return res
	@end

	@method onIfBranch element, data, context
		var data_condition = data[-2]
		var data_body      = data[-1]
		var block          = F createBlock ()
		# FIXME: I don't get why I have to use data_body data
		var code           = on (data_body data)
		_setCode (block, code)
		return [on(data_condition), block]
	@end

	@method onElifBranch element, data, context
		var data_condition = data[-2]
		var data_body      = data[-1]
		var block          = F createBlock ()
		# FIXME: I don't get why I have to use data_body data
		_setCode (block, on(data_body data))
		return [on(data_condition), block]
	@end

	@method onElseBranch element, data, context
		var data_body = data[-1]
		var block          = F createBlock ()
		# FIXME: I don't get why I have to use data_body data
		_setCode (block, on(data_body data))
		return [block]
	@end

	@method onIteration element, data, context
		return on (element resolve ("for", data))
	@end

	@method onRepetition element, data, context
		return on (element resolve ("while", data))
	@end

	@method onTry element, data, context
		var try_branch     = on (element resolve ("try",     data))
		var catch_branch   = on (element resolve ("catch",   data))
		var finally_branch = on (element resolve ("finally", data))
		return F intercept (try_branch, catch_branch, finally_branch)
	@end

	@method onForBranch element, data, context
		var params   = on (element resolve ("params", data))
		var expr     = on (element resolve ("expr",   data))
		var body     = on (element resolve ("body",   data))
		var process  = F createClosure (params)
		_setCode (process, body)
		return F iterate (expr, process)
	@end

	@method onWhileBranch element, data, context
		var condition = on (element resolve ("condition", data))
		var body      = on (element resolve ("body",   data))
		var process   = F createBlock ()
		_setCode (process, body)
		return F repeat (condition, process)
	@end

	@method onTryBranch element, data, context
		var body      = on (element resolve ("body",   data))
		var process   = F createBlock ()
		_setCode (process, body)
		return process
	@end

	@method onCatchBranch element, data, context
		var body      = on (element resolve ("body",   data))
		var param     = on (element resolve ("param",  data))
		var args      = [F _param(param[0] getReferenceName ())]
		var process   = F createClosure (args)
		_setCode (process, body)
		return process
	@end


	@method onFinallyBranch element, data, context
		var body      = on (element resolve ("body",   data))
		var process   = F createBlock ()
		_setCode (process, body)
		return process
	@end

	@method onBlockBody element, data, context
		# Returns the code contained in the block body
		return on(data[2])
	@end

	@method onBlockLine element, data, context
		# Returns the statements contained in the block line
		return on(data[1])
	@end

	@method onEmbed element, data, context
		var body     = on (element resolve ("body", data))
		var language = element resolve ("language", data) data
		# FIXME
		language = "JavaScript"
		# if language
		# 	language = language group ()
		# end
		var lines    = []
		for line in body
			lines append (line[1] group (1))
		end
		return F embed (language, "\n" join (lines))
	@end

	# =========================================================================
	# EXPRESSIONS
	# =========================================================================

	@method onExpression match
		# Prefix is the current value of the expression, and suffixes is
		# a sequence of operations on the value (invocation, resolution, etc).
		# Suffixes is because we wanted to avoid recursive grammars, which
		# is not well supported in PEG parsers.
		let prefix   = process (match[0])
		let suffixes = process (match[1])
		var current  = None
		# NOTE: This should be abstracted
		if isinstance(prefix, interfaces ILiteral) or isinstance(prefix, interfaces IValue) or isinstance(prefix, interfaces IClosure)
			current  = prefix
		elif isinstance(prefix, interfaces IComputation) or isinstance(prefix, interfaces IResolution) or isinstance(prefix, interfaces IInvocation) or isinstance (prefix, interfaces IInstanciation) or isinstance (prefix, interfaces IAccessOperation) or isinstance(prefix, interfaces IExcept)
			current  = prefix
		elif isinstance(prefix, interfaces IReference)
			current  = F resolve (prefix)
		else
			# ipdb set_trace ()
			raise Exception("Prefix not supported yet: " + str(current))
		end
		current = _applySuffixes (current, suffixes)
		if isinstance (current, interfaces IComputation)
			current = _reorderComputation (current)
		end
		return current
	@end

	@method _reorderComputation value
	| Reorders a sequence of computations according to operators priorities.
	| This method is called by `onExpression` and applied from right
	| to left.
		var b = value getRightOperand ()
		# When we have: A op1 B
		# where               B = (C op2 D)
		if isinstance (b, interfaces IComputation)
			var op1_p  = value getOperator () getPriority ()
			var op2_p  = b     getOperator () getPriority ()
			# ...and that priority(op1) >= priority(op2)
			if op1_p >= op2_p
				# We refactor the current computation so that it becomes
				#     B op2 D
				# where
				#     B = (A op1 C)
				# resulting in
				#     (A op1 C) op2 D
				var a  = value getLeftOperand  () detach ()
				var c  = b     getLeftOperand  () detach ()
				var d  = b     getRightOperand () detach ()
				var o1 = value getOperator     () detach ()
				var o2 = b     getOperator     () detach ()
				value setOperator (o2)
				value setRightOperand (d)
				b detach ()
				b setLeftOperand  (a)
				b setOperator     (o1)
				b setRightOperand (c)
				# but we need to reorder the new compuation (A op1 C) as we changed it
				value setLeftOperand (_reorderComputation(b))
			end
			return value
		else
			return value
		end
	@end

	@method _applySuffixes value, suffixes
	| Applies the suffixes to the current value, modifying it
		if suffixes
			# We go from left to right
			for args in suffixes
				var name = args[0]
				if name == "Invocation"
					if type(args[1]) == list or type(args[1]) == tuple
						value = F invoke_args (value, args[1])
					else
						value = F invoke (value, args[1])
					end
				if name == "ComputationInfix"
					# FIXME: Re-ordering should be appled here
					var op = normalizeOperator (args[1])
					if op == ".."
						value = F enumerate (value, args[2])
					else
						value = F compute (F _op (op, getOperatorPriority(op)), value, args[2])
					end
				if name == "Decomposition"
					for _ in args[1]
						value = F resolve (_, value)
					end
				if name == "Access"
					value = F access (value, args[1])
				if name == "Slice"
					value = F slice  (value, args[1], args[2])
				else
					# ipdb set_trace ()
					raise new Exception ("Suffix not supported yet: " + str(name))
				end
			end
		end
		return value
	@end

	@method onExpressionList match
	| Returns a list of expressions [model.Expression]
		let head = process (match[0])
		let tail = process (match[1])
		let res  = [head]
		for _ in tail
			# We have _ = [',', <model.Reference>]
			#              0        1
			res append (_[1])
		end
		return res
	@end

	@method onExpressionBlock match
	| Returns a list of expressions [model.Expression]
		let lines = process (match[1])
		let res   = []
		for _ in lines
			# We have _ = [EOL, Indent, ExpressionList]
			#              0    1       2
			res += _[2]
		end
		return res
	@end

	# =========================================================================
	# PREFIXES
	# =========================================================================

	@method onPrefixes match
		return process(match[0])
	@end

	@method onComputationPrefix element, data, content
		var operator = normalizeOperator (on (data[0]) group ())
		var operand  = on (data[1])
		return F compute (F _op (operator, getOperatorPriority (operator)), operand)
	@end

	@method onParentheses match
		return process (match[1])
	@end

	@method onException match
		return F exception (process (match[1]))
	@end

	@method onInstanciation element, data, content
		# Both name and params are suffixes so they're returned as couples,
		# where we want the second value
		var name   = on (element resolve ("target",   data))
		var params = on (element resolve ("params", data))[1]
		@embed Python
		|if not (isinstance(params, list) or isinstance(params, tuple)): params = (params,)
		|return F.instanciate(name, *(params or []))
		@end
	@end

	# =========================================================================
	# SUFFIXES
	# =========================================================================

	@method onSuffixes match
	| This rule returns the data AS-IS, without modifying it. This is necessary
	| because suffixes need a prefix to be turned into a proper expression.
		return process (match[0])
	@end

	@method onInvocation match
	| Returns ("Invocation", [args])
		let arguments_or_litteral = process (match[0])
		var args                  = []
		for _ in process (match[0])
			if isinstance(_, interfaces IElement)
				args append (_)
			end
		end
		return [match element name, args]
	@end


	@method onComputationInfix match
	| Returns ("ComputationInfix", OPERATOR:String, Expression)
		return [match element name, match[0] group 0, process (match[1])]
	@end

	@method onAccess match
	| Returns [("Access", INDEX:Element)]
		return [match element name, process(match[1])]
	@end

	@method onDecomposition match
	| Returns [("Decomposition", [ref:Reference])]
		let slots  = [process (match[1])]
		for _ in process(match[2])
			slots append (_[1])
		end
		return [match element name, slots]
	@end

	@method onSlice element, data, context
		var start_index = on(data[1])
		var end_index   = on(data[3])
		return [element name, start_index, end_index]
	@end

	# =========================================================================
	# OPERATIONS
	# =========================================================================

	@method onAllocation match
	| Returns a list of operations. If there's only one operation,
	| then it is a single allocation, otherwise it will be a mutliple
	| allocation with an automatic variable name.
		# We resolve "var SYMBOLS | REST = VALUE"
		var res          = None
		let symbols = process (match[2])
		let rest    = process (match[3])
		let value   = access (process (match[4]), 1)
		if (len(symbols) == 1) and (not rest)
			# This is a single allocation with no rest
			var slot = F _slot (symbols[0] getReferenceName())
			res = [F allocate (slot, value)]
		else
			# This is a multiple allocation with maybe a rest
			res = []
			# We create an intermediate expression to store the result to
			# be sliced so that we don't evaluate the same code twice
			var temp_slot  = F _slot ()
			res append (F allocate (temp_slot, value))
			var slot_value = F resolve (F _ref (temp_slot getName ()))
			var i = 0
			# We create individual allocations for each access
			for s in symbols
				var slot      = F _slot  (s getReferenceName ())
				var sub_value = F access (slot_value copy (), F _number(i))
				res append (F allocate (slot, sub_value))
				i += 1
			end
			# We create a slice for the rest
			if rest
				var slot      = F _slot  (rest getReferenceName ())
				var sub_value = F slice (slot_value copy (), i)
				res append (F allocate (slot, sub_value))
			end
		end
		return res
	@end

	@method onAssignment element, data, context
		var data_before = element resolve ("before", data)
		var data_main   = element resolve ("main",   data)
		var data_rest   = element resolve ("rest",   data)
		var data_op     = element resolve ("op",     data)
		var lvalue      = on(data_main)
		var op_value    = on(data_op)
		var op          = op_value[0] group ()
		if op == "="
			return F assign (lvalue, op_value[1])
		if op == "?="
			# In this case: A ?= B is the equivalent of
			# if not (A) -> A = B
			var predicate  = F compute (F _op "not", lvalue)
			var assignment = F assign  (lvalue copy (), op_value[1])
			var match      = F matchExpression (predicate, assignment)
			var res        = F select ()
			res addRule (match)
			return res
		else
			# FIXME: Right now the lvalue is copied, but it could be optimized by
			# ex:
			# a[0][1][2] += 2
			# could be
			# __temp__ = a[0][1]
			# __temp__[2] = __temp__[2] + 2
			# instead of
			# a[0][1][2] = a[0][1][2]
			var res    = None
			var sub_op = normalizeOperator(op[0])
			# ipdb set_trace ()
			# if isinstance (lvalue, interfaces ISliceOperation) and isinstance (lvalue getOpArgument 0, interface IOperation)
			# 	res = []
			# 	res append (F assign ("__temp__", lvalue getOpArgument 0))
			# 	var mod_lvalue = lvalue copy detach ()
			# 	mod_lvalue setOpArgument (0, F resolve "__temp__")
			# 	#res append (mod_lvalue)
			# 	res append (F compute (F _op (sub_op, getOperatorPriority (sub_op)), F resolve "__temp__", op_value[1]))
			# 	res append (F assign (mod_lvalue, F resolve "__temp__"))
			# 	return res
			# else
			var c = F compute (F _op (sub_op, getOperatorPriority (sub_op)), lvalue, op_value[1])
			return F assign (lvalue copy () detach (), c)
		end
	@end

	@method onAssignable element, data, context
		var data_lvalue   = data[0]
		var data_suffixes = data[1]
		var lvalue        = on (data_lvalue)
		var suffixes      = on (data_suffixes)
		return _applySuffixes (lvalue, suffixes)
	@end

	@method onIterationLine element, data, context
		var data_lvalue   = data[0]
		var data_closure  = data[2]
		var lvalue        = on (data_lvalue)
		var closure       = on (data_closure)
		return F iterate (lvalue, closure)
	@end

	@method onTermination match
		return F returns (process(match[1]))
	@end

	# =========================================================================
	# SYMBOLS & DECLARATIONS
	# =========================================================================

	@method onParameter match
		let name_type  = process(match[0])
		var value      = _tryGet (process(match[1]), 1, None)
		# FIXME: Support type
		# FIXME: Support keywords?
		return F _param (name_type[0] getReferenceName (), None, value)
	@end

	@method onParameterList match
		let res      = [process(match[0])]
		let ellipsis = process(match[2])
		for _ in process(match[1])
			# We have _ = [COMMA, <model.Parameter>]
			#              0        1
			res append (_[1])
		end
		if ellipsis
			res[-1] setRest (True)
		end
		return res
	@end

	@method onArgumentsEmpty match
		return []
	@end

	@method onArgumentsMany match
		let line = process (match[1])
		let body = process (match[2])
		return filterNull (line + body)
	@end

	@method onSymbolList match
	| Returns `[model.Reference]`
		let head = process (match[0])
		let tail = process (match[1])
		let more = process (match[2])
		let res  = [head]
		for _ in tail
			# We have _ = [',', <model.Reference>]
			#              0        1
			res append (_[1])
		end
		# FIXME: Check why there would be an ELLIPSIS in SymbolsList
		# NOTE: There would be an ellipsis for list destructuring
		assert (not more)
		return res
	@end

	@method onNameType match
	| Returns a couple (name, type) where type might be None.
		return [process (match[0]), process (match[1])]
	@end

	@method onFQName match
	| A fully qualified name that will return an absolute reference
		let head = process (match[0])
		let tail = process (match[1])
		let res  = [head getReferenceName ()]
		for _ in tail
			# We have _ = [DOT, NAME]
			#              0        1
			res append (_[1] getReferenceName ())
		end
		let full_name = "." join (res)
		return F _absref (full_name)
	@end


	# =========================================================================
	# COMPOUND TYPES (LIST)
	# =========================================================================

	@method onArray match
		let list  = process (match[1]) or []
		let block = process (match[2]) or []
		return F _list (list + block)
	@end

	# =========================================================================
	# COMPOUND TYPES (MAP)
	# =========================================================================

	@method onMap element, data, context
		var res        = F _dict ()
		var data_list  = element resolve (g symbols KeyValueList,  data)
		var data_block = element resolve (g symbols KeyValueBlock, data)
		var elements   = (on(data_list) or []) + (on(data_block) or [])
		for _ in elements
			if _
				res setValue (_[0], _[1])
			end
		end
		return res
	@end

	@method onKeyValueList element, data, context
		var res  = []
		var expr = on (data)
		res append (expr[0])
		for _ in (expr[1] or [])
			# We have _ = [COMMA, <model.KeyValue>]
			#              0       1
			res append (_[1])
		end
		return res
	@end

	@method onKeyValueBlock element, data, context
		var res  = []
		var expr = on (data)
		res append (expr[0])
		for _ in (expr[1] or [])
			# We have _ = [EOL, CheckIndent, KeyValueList]
			#              0    1            2
			res += _[2]
		end
		return res
	@end

	@method onKeyValue element, data, context
		var key   = element resolve (g symbols Key,        data)
		var value = element resolve (g symbols Expression, data)
		return [on(key), on(value)]
	@end

	@method onKey element, data, context
		var res = on (data)
		if isinstance(res, interfaces IElement)
			return res
		else
			# We have res = ( EXPRESSION )
			#               0 1          2
			return res[1]
		end
	@end

	# =========================================================================
	# LITERALS
	# =========================================================================

	@method onString match
		let raw     = process (match[0])
		# FIXME: Proper string decoding
		let decoded = eval (raw)
		return F _string (decoded)
	@end

	@method onNUMBER match
		let raw     = match[0]
		# FIXME: Proper number decoding
		let decoded = eval (raw)
		return F _number (decoded)
	@end

	@method onSYMBOLIC match
		var raw_symbol     = match group ()
		if raw_symbol == "Undefined"
			return F _symbol (raw_symbol)
		if raw_symbol == "None"
			return F _symbol (raw_symbol)
		if raw_symbol == "Nothing"
			return F _symbol (raw_symbol)
		if raw_symbol == "Timeout"
			return F _symbol (raw_symbol)
		else
			raise new Exception("Unknown symbol:" + raw_symbol())
		end
	@end

	@method onNAME match
		return F _ref (match group 2)
	@end

	@method onKEY match
		return F _string (match group ())
	@end

	# =========================================================================
	# COMMENTS & DOCUMENTATION
	# =========================================================================

	@method onDocumentation match
		let lines = []
		for l in process (match[0])
			lines append (l[1][1:])
		end
		return F doc ("\n" join (lines))
	@end

	# =========================================================================
	# AST
	# =========================================================================
	# The following methods deal with AST elements that we need to prune
	# as they're not relevant to the semantic.

	# @method onRepeat element, data, context
	# | Converts the given repeat to None, the result (if the repeat is optional),
	# | or an array (zero or more)
	# 	var result = filterNull (on (data))
	# 	if result
	# 		if element isOptional ()
	# 			return result[0]
	# 		else
	# 			return result
	# 		end
	# 	else
	# 		return None
	# 	end
	# @end

	@method onCheckIndent match
		# We bypass check indent, as it does not contain any valuable or
		# interesting result
		return None
	@end

	@method onEOL match
		# We bypass check indent, as it does not contain any valuable or
		# interesting result
		return None
	@end

@end

# EOF - vim: ts=4 sw=4 noet
