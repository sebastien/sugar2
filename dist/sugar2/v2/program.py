#8< ---[sugar2/v2/program.py]---
#!/usr/bin/env python
# encoding: utf-8
import sys
__module__ = sys.modules[__name__]
from sugar2.helpers import doIndent, doCheckIndent, doDedent, doBlockStart, doBlockEnd, listOf
from sugar2.v2.types import injectTypes
import libparsing
__module_name__ = 'sugar2.v2.program'
G = None
def declaration (grammar, name, prefix):
	self=__module__
	g=grammar
	s=g.symbols
	return g.rule(name, s.CheckIndent, prefix, s.NameType._as(u'name'), g.arule(g.aword(u'='), s.Expression).optional()._as(u'value'), s.EOL, s.Documentation.optional()._as(u'documentation'))


def function (grammar, name, prefix, anonymous=None):
	self=__module__
	if anonymous is None: anonymous = False
	g=grammar
	s=grammar.symbols
	if anonymous:
		return g.rule(name, s.CheckIndent, prefix._as(u'type'), s.NOTHING._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'), s.Body._as(u'body'), s.ConstructSuffixes.zeroOrMore()._as(u'suffixes'))
	elif True:
		return g.rule(name, s.CheckIndent, prefix._as(u'type'), s.NameType._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'), s.Body._as(u'body'), s.ConstructSuffixes.zeroOrMore()._as(u'suffixes'))


def abstractFunction (grammar, name, prefix):
	self=__module__
	g=grammar
	s=grammar.symbols
	return g.rule(name, s.CheckIndent, s.oabstract, prefix._as(u'type'), s.NameType._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'), s.ConstructSuffixes.zeroOrMore()._as(u'suffixes'))


def construct (grammar, name, tag, contents):
	self=__module__
	g=grammar
	s=grammar.symbols
	return g.rule(name, s.CheckIndent, s.oabstract.optional(), tag, s.NAME._as(u'name'), s.Parents.optional()._as(u'inherits'), s.EOL, s.Documentation.optional()._as(u'documentation'), s.Indent, contents.zeroOrMore()._as(u'body'), s.Dedent, s.ConstructSuffixes.zeroOrMore()._as(u'suffixes'))


def createProgramGrammar (g=None):
	self=__module__
	if g is None: g = libparsing.Grammar(u'Sugar', False)
	s=g.symbols
	g.token(u'SPACE', u'[ ]+')
	g.token(u'TABS', u'\t*')
	g.token(u'EMPTY_LINES', u'([ \t]*\n)+')
	g.token(u'COMMENT', u'[ \t]*\\#[^\n]*')
	g.token(u'EOL', u'[ ]*\n(\\s*\n)*')
	g.token(u'ANY', u'[^\n]*')
	g.token(u'NUMBER', u'(0x[A-Fa-f0-9]+)|(0b[01]+)|(0o[0-8]+)|([0-9]+(\\.[0-9]+)?)')
	g.token(u'NUMBER_UNIT', u'[0-9]+(\\.[0-9]+)?(ms|s|m|h|d|w|deg)')
	g.token(u'NAME', u'(\\\\?)([\\$_A-Za-z][_\\w]*)')
	g.token(u'VALUE', u'[\\w\\d_\\-\\+\\*\\-]+')
	g.token(u'FQNAME', u'(\\\\?)([\\$_A-Za-z][\\._\\w]*)')
	g.token(u'KEY', u'[\\$_\\-A-Za-z][_\\-\\w]*')
	g.token(u'INFIX_OPERATOR', u'([\\-\\+\\*\\/\\%]|\\<=|\\>=|\\<\\<?|\\>\\>?|==|\\!=|\\.\\.|\u2025|\\|\\||&&|\\||not\\s+in\\s+|in\\s+|and\\s+|or\\s+|is\\s+not\\s+|is\\s+|\\*\\*)')
	g.token(u'PREFIX_OPERATOR', u'(not\\s+|\\-)')
	g.token(u'NEW_OPERATOR', u'new\\s+')
	g.token(u'THROW_OPERATOR', u'(raise|throw)\\s+')
	g.token(u'ASSIGN_OPERATOR', u'[\\?\\*\\+\\-\\/\\%]?=')
	g.token(u'EVENT_OPERATOR', u'\\![!\\+\\-]?')
	g.token(u'SYMBOLIC', u'None|Undefined|Nothing|Timeout')
	g.token(u'STRING_SQ', u"'(\\\\'|[^'\\n])*'")
	g.token(u'STRING_DQ', u'"(\\\\"|[^"\\n])*"')
	g.token(u'STRING_MQ', u'"""(.+)"""')
	g.token(u'STRING_MQ_START', u'"""(.*)\n')
	g.token(u'STRING_MQ_END', u'(.*)"""')
	g.token(u'STRING_MQ_LINE', u'[^"\n]*("[^"\n]|""[^"\n])*[^"\n]*')
	g.token(u'DOCSTRING', u'\\|[^\n]*')
	g.token(u'EMBED_LINE', u'([^\n]*)')
	g.token(u'VERSION', u'[0-9]+(\\.[0-9]+)?(\\.[0-9]+)?[a-zA-Z_]*')
	g.token(u'DOT_OR_SPACE', u'\\.|[ \t]+')
	g.token(u'ITERATOR', u'::[\\?=\\<\\>]?')
	g.token(u'ELLIPSIS', u'\\.\\.\\.|\u2025')
	g.token(u'ARROW', u'\\-\\>|\u2192')
	g.word(u'LP', u'(')
	g.word(u'RP', u')')
	g.word(u'LB', u'{')
	g.word(u'RB', u'}')
	g.word(u'LSB', u'[')
	g.word(u'RSB', u']')
	g.word(u'COMMA', u',')
	g.word(u'DOT', u'.')
	g.word(u'COLON', u':')
	g.word(u'SEMICOLON', u';')
	g.word(u'UNDERSCORE', u'_')
	g.word(u'PIPE', u'|')
	g.word(u'EQUALS', u'=')
	g.word(u'TILDE', u'~')
	g.word(u'BANG', u'!')
	g.condition(u'NOTHING')
	g.word(u'_var', u'var')
	g.word(u'_let', u'let')
	g.word(u'_if', u'if')
	g.word(u'_elif', u'elif')
	g.word(u'_else', u'else')
	g.word(u'_for', u'for')
	g.word(u'_while', u'while')
	g.word(u'_in', u'in')
	g.word(u'_from', u'from')
	g.word(u'_as', u'as')
	g.word(u'_try', u'try')
	g.word(u'_catch', u'catch')
	g.word(u'_finally', u'finally')
	g.word(u'_match', u'match')
	g.word(u'_type', u'is?')
	g.word(u'oabstract', u'@abstract')
	g.word(u'oimport', u'@import')
	g.word(u'otarget', u'@target')
	g.word(u'ofeature', u'@feature')
	g.word(u'omodule', u'@module')
	g.word(u'oversion', u'@version')
	g.word(u'ofunction', u'@function')
	g.word(u'oclass', u'@class')
	g.word(u'otrait', u'@trait')
	g.word(u'osingleton', u'@singleton')
	g.word(u'oevent', u'@event')
	g.word(u'oproperty', u'@property')
	g.word(u'ogetter', u'@getter')
	g.word(u'osetter', u'@setter')
	g.word(u'oshared', u'@shared')
	g.word(u'ooperation', u'@operation')
	g.word(u'oconstructor', u'@constructor')
	g.word(u'omethod', u'@method')
	g.word(u'ogroup', u'@group')
	g.word(u'oend', u'@end')
	g.word(u'oembed', u'@embed')
	g.word(u'owhen', u'@when')
	g.word(u'owhere', u'@where')
	g.word(u'oexample', u'@example')
	g.procedure(u'Indent', doIndent)
	g.procedure(u'Dedent', doDedent)
	g.rule(u'CheckIndent', s.TABS._as(u'tabs'), g.acondition(doCheckIndent))
	g.rule(u'Comment', s.COMMENT._as(u'text'), s.EOL)
	g.rule(u'EmptyLines', s.EMPTY_LINES)
	g.rule(u'DocumentationLine', s.CheckIndent, s.DOCSTRING, s.EOL)
	g.rule(u'Documentation', s.DocumentationLine.oneOrMore())
	g.rule(u'StringLine', s.CheckIndent._as(u'indent'), s.STRING_MQ_LINE._as(u'text'), s.EOL)
	g.rule(u'StringMultiEnd', s.CheckIndent, s.STRING_MQ_END._as(u'end'))
	g.rule(u'StringMulti', s.STRING_MQ_START._as(u'start'), s.StringLine.zeroOrMore()._as(u'lines'), s.StringMultiEnd._as(u'end'))
	g.group(u'String', s.STRING_MQ, s.StringMulti, s.STRING_SQ, s.STRING_DQ)
	g.rule(u'Expression')
	g.group(u'Number', s.NUMBER_UNIT, s.NUMBER)
	g.group(u'Key', s.KEY, s.Number, s.String, g.arule(s.LP, s.Expression, s.RP))
	g.rule(u'KeyValue', s.Key, s.COLON, s.Expression)
	g.rule(u'ImplicitKey', s.KEY)
	g.group(u'Entry', s.KeyValue, s.ImplicitKey)
	g.rule(u'EntryList', s.Entry, g.arule(s.COMMA, s.Entry).zeroOrMore(), s.COMMENT.optional())
	g.group(u'EntryLine', s.EntryList, s.COMMENT)
	g.rule(u'ExpressionList', s.Expression, g.arule(s.COMMA, s.Expression).zeroOrMore(), s.COMMENT.optional())
	g.group(u'ExpressionLine', s.ExpressionList, s.COMMENT)
	g.rule(u'ExpressionBlock', s.Indent, g.arule(s.EOL, s.CheckIndent, s.ExpressionLine).oneOrMore()._as(u'content'), s.Dedent)
	g.rule(u'NamedExpression', g.arule(s.NAME, s.COLON).optional()._as(u'name'), s.Expression._as(u'value'))
	g.rule(u'RestExpression', s.ELLIPSIS, s.Expression._as(u'value'))
	g.group(u'NamedEntry', s.Expression, s.NamedExpression, s.RestExpression)
	g.rule(u'NamedExpressionList', s.NamedEntry, g.arule(s.COMMA, s.NamedEntry).zeroOrMore(), s.COMMA.optional()._as(u'comma'), s.COMMENT.optional())
	g.group(u'NamedExpressionLine', s.NamedExpressionList, s.COMMENT)
	g.rule(u'NamedExpressionBlock', s.Indent, g.arule(s.EOL, s.CheckIndent, s.NamedExpressionLine).oneOrMore()._as(u'content'), s.Dedent)
	g.rule(u'EntryBlock', s.Indent, g.arule(s.EOL, s.CheckIndent, s.EntryLine).oneOrMore()._as(u'content'), s.Dedent)
	g.rule(u'Array', s.LSB, s.ExpressionList.optional()._as(u'head'), s.ExpressionBlock.optional()._as(u'tail'), g.arule(s.EOL, s.CheckIndent).optional(), s.RSB)
	g.rule(u'Tuple', s.LP, s.NamedExpressionList.optional()._as(u'head'), s.NamedExpressionBlock.optional()._as(u'tail'), g.arule(s.EOL, s.CheckIndent).optional(), s.RP)
	g.rule(u'Map', s.LB, s.EntryList.optional()._as(u'head'), s.EntryBlock.optional()._as(u'tail'), g.arule(s.EOL, s.CheckIndent).optional(), s.RB)
	injectTypes(g)
	g.rule(u'NameType', s.NAME, g.arule(s.COLON, s.TypeValue).optional())
	g.rule(u'FQName', s.NAME, g.arule(s.DOT_OR_SPACE, s.NAME).zeroOrMore())
	g.rule(u'Parameter', s.NameType._as(u'name'), g.arule(s.EQUALS, s.Expression).optional()._as(u'value'))
	g.rule(u'ParameterList', s.Parameter, g.arule(s.COMMA, s.Parameter).zeroOrMore(), s.ELLIPSIS.optional())
	g.rule(u'SymbolList', s.NameType._as(u'name'), g.arule(s.COMMA, s.NameType).zeroOrMore(), s.ELLIPSIS.optional())
	g.rule(u'ArgumentsEmpty', s.LP, s.RP)
	g.group(u'ClosureStatement')
	g.group(u'ClosureBody')
	g.rule(u'ClosureParameters', s.ParameterList.optional(), s.PIPE)
	g.rule(u'EmptyClosure', s.LB, s.ClosureParameters, s.RB)
	g.rule(u'InlineClosure', s.LB, s.ClosureParameters.optional()._as(u'params'), s.ClosureStatement._as(u'body'), s.RB)
	g.rule(u'BlockClosure', s.LB, s.ClosureParameters.optional()._as(u'params'), s.ClosureBody._as(u'body'), s.CheckIndent, s.RB)
	g.group(u'Closure', s.BlockClosure, s.InlineClosure, s.EmptyClosure)
	g.group(u'Literal', s.Number, s.SYMBOLIC, s.String, s.Array, s.Tuple, s.Map, s.Closure)
	g.rule(u'Reference', s.NAME, g.arule(s.DOT, s.NAME).zeroOrMore())
	g.rule(u'Decomposition', s.DOT_OR_SPACE, s.Reference)
	g.rule(u'ComputationInfix', s.INFIX_OPERATOR, s.Expression)
	g.rule(u'Access', s.LSB, s.Expression, s.RSB)
	g.rule(u'Slice', s.LSB, s.Expression.optional(), s.COLON, s.Expression.optional(), s.RSB)
	g.group(u'Arguments', s.Literal, s.ArgumentsEmpty)
	g.group(u'Invocation', s.Arguments)
	g.rule(u'InfixInvocation', s.TILDE, s.NAME._as(u'name'), s.Expression._as(u'rvalue'))
	g.rule(u'Parentheses', s.LP, s.Expression, s.RP)
	g.group(u'Suffixes')
	g.rule(u'ChainLine', s.EOL, s.Indent, s.CheckIndent, g.agroup(s.COMMENT, s.Reference, s.Suffixes).oneOrMore()._as(u'content'), s.Dedent)
	g.rule(u'Chain', g.agroup(s.ELLIPSIS, s.COLON)._as(u'type'), s.ChainLine.oneOrMore()._as(u'lines'))
	g.rule(u'IterationSuffix', s.ITERATOR._as(u'op'), s.Expression._as(u'rvalue'))
	g.rule(u'ConditionSuffix', g.agroup(s._if, s._else)._as(u'type'), s.SPACE, s.Expression._as(u'value'))
	g.rule(u'EventOperation', s.EVENT_OPERATOR._as(u'operator'), g.agroup(s.Reference, s.String)._as(u'name'), s.Arguments.optional()._as(u'value'))
	g.rule(u'TypeSuffix', s._type, s.TypeValue._as(u'type'))
	g.rule(u'MatchSuffixLine', s.ARROW, s.Expression._as(u'body'))
	g.rule(u'MatchSuffixBlock', s.EOL, s.Comment.zeroOrMore(), s.Indent, s.CheckIndent, s.Expression._as(u'body'), s.COMMENT.optional(), s.Dedent)
	g.rule(u'MatchSuffixBranch', s.EOL, s.Comment.zeroOrMore(), s.CheckIndent, g.agroup(s._else, s.UNDERSCORE, s.Suffixes.oneOrMore(), s.COMMENT.optional())._as(u'condition'), g.agroup(s.MatchSuffixLine, s.MatchSuffixBlock)._as(u'body'))
	g.rule(u'MatchSuffixBody', s.Indent, s.MatchSuffixBranch.oneOrMore()._as(u'branches'), s.Dedent)
	g.rule(u'MatchSuffix', s._match, g.agroup(s.MatchSuffixBody)._as(u'branches'))
	g.group(u'Prefixes', s.Literal, g.rule(u'Exception', s.THROW_OPERATOR, s.Expression._as(u'expression')), g.rule(u'Instanciation', s.NEW_OPERATOR, g.agroup(s.FQName, s.Parentheses)._as(u'target'), s.Invocation._as(u'params')), g.rule(u'ComputationPrefix', s.PREFIX_OPERATOR, s.Expression), s.EventOperation, s.NAME, s.Parentheses)
	s.Suffixes.set(s.TypeSuffix, s.Chain, s.IterationSuffix, s.ConditionSuffix, s.ComputationInfix, s.EventOperation, s.MatchSuffix, s.Decomposition, s.Access, s.Slice, s.Invocation, s.InfixInvocation)
	s.Expression.set(s.Prefixes, s.Suffixes.zeroOrMore())
	g.rule(u'Assignable', s.NAME, g.agroup(s.Decomposition, s.Access, s.Slice, s.Invocation).zeroOrMore())
	g.rule(u'Allocation', g.agroup(s._var, s._let), s.SPACE, s.SymbolList._as(u'symbols'), g.arule(s.PIPE, s.NameType).optional()._as(u'rest'), g.arule(s.EQUALS, s.Expression).optional()._as(u'value'))
	g.rule(u'Assignment', g.arule(s.Assignable, s.COMMA).zeroOrMore()._as(u'before'), s.Assignable._as(u'main'), g.arule(s.PIPE, s.Assignable).optional()._as(u'rest'), g.arule(s.ASSIGN_OPERATOR, s.Expression)._as(u'op'))
	g.rule(u'Termination', g.aword(u'return'), s.Expression.optional())
	g.rule(u'Break', g.aword(u'break'))
	g.rule(u'Pass', g.aword(u'pass'))
	g.rule(u'Continue', g.aword(u'continue'))
	g.group(u'Block')
	g.group(u'Code')
	g.group(u'Statement', s.Comment, s.Allocation, s.Assignment, s.Termination, s.Break, s.Continue, s.Pass, s.Expression)
	g.rule(u'Statements', s.Statement, g.arule(s.SEMICOLON, s.Statement).zeroOrMore())
	g.rule(u'Line', s.CheckIndent, s.Statements.optional(), s.COMMENT.optional(), s.EOL)
	g.rule(u'BlockStart', s.CheckIndent)
	g.rule(u'BlockBody', s.EOL, s.Indent, s.Code.zeroOrMore()._as(u'body'), s.Dedent)
	g.procedure(u'BlockEnd', doBlockEnd)
	g.rule(u'IfBlock', s.BlockStart, s._if, s.Expression._as(u'condition'), g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'ElifBlock', s.BlockStart, s._elif, s.Expression._as(u'condition'), g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'ElseBlock', s.BlockStart, s._else, g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'WhileBlock', s.BlockStart, s._while, s.Expression._as(u'condition'), g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'TryBlock', s.BlockStart, s._try, g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'FinallyBlock', s.BlockStart, s._finally, g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'CatchBlock', s.BlockStart, s._catch, s.NameType.optional()._as(u'param'), g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'ForBlock', s.BlockStart, s._for, s.ParameterList._as(u'params'), s._in, s.Expression._as(u'expr'), g.agroup(s.BlockBody)._as(u'body'))
	g.rule(u'MatchBranch', s.BlockStart, g.agroup(s._else, s.UNDERSCORE, s.Suffixes.oneOrMore(), s.COMMENT.optional())._as(u'condition'), s.BlockBody._as(u'body'))
	g.rule(u'MatchBody', s.EOL, s.Comment.zeroOrMore(), s.Indent, s.MatchBranch.zeroOrMore()._as(u'branches'), s.Dedent)
	g.rule(u'MatchBlock', s.BlockStart, s._match, s.Expression._as(u'expression'), s.COMMENT.optional(), g.agroup(s.MatchBody)._as(u'branches'))
	g.rule(u'ConditionalBlock', s.BlockStart, s.IfBlock._as(u'if'), s.ElifBlock.zeroOrMore()._as(u'elif'), s.ElseBlock.optional()._as(u'else'), s.BlockEnd)
	g.group(u'Conditional', s.ConditionalBlock)
	g.rule(u'Try', s.BlockStart, s.TryBlock._as(u'try'), s.CatchBlock.optional()._as(u'catch'), s.FinallyBlock.optional()._as(u'finally'), s.BlockEnd)
	g.rule(u'Repetition', s.BlockStart, s.WhileBlock._as(u'while'), s.BlockEnd)
	g.rule(u'Iteration', s.BlockStart, s.ForBlock._as(u'for'), s.BlockEnd)
	g.rule(u'Selection', s.BlockStart, s.MatchBlock._as(u'match'), s.BlockEnd)
	s.Block.set(s.Conditional, s.Repetition, s.Iteration, s.Selection, s.Try)
	s.Code.set(s.Comment, s.Block, s.Line)
	g.rule(u'Body', s.Indent, s.Code.zeroOrMore()._as(u'code'), s.Dedent)
	g.rule(u'OWhen', s.CheckIndent, s.owhen, s.Expression._as(u'expression'), s.EOL)
	g.rule(u'OWhere', s.CheckIndent, s.owhere, s.NAME.optional()._as(u'name'), s.EOL, s.Documentation.optional()._as(u'doc'), s.Body._as(u'body'))
	g.group(u'OExampleBody')
	g.rule(u'OExample', s.CheckIndent, s.oexample, s.NAME.optional()._as(u'name'), s.EOL, s.Documentation.optional()._as(u'doc'), g.arule(s.Indent, s.OExampleBody._as(u'module'), s.Dedent)._as(u'body'))
	g.rule(u'CustomDecorator', s.CheckIndent, s.BANG, s.FQName._as(u'name'), s.Expression.optional()._as(u'arguments'), s.EOL)
	g.group(u'ConstructSuffixes', s.OWhere, s.OExample)
	g.group(u'Decorator', s.OWhen, s.CustomDecorator)
	s.ClosureStatement.set(s.Statements)
	s.ClosureBody.set(s.BlockBody)
	declaration(g, u'ClassAttribute', s.oshared)
	declaration(g, u'ModuleAttribute', s.oshared)
	declaration(g, u'Attribute', s.oproperty)
	g.rule(u'Event', s.CheckIndent, s.oevent, s.NameType._as(u'name'), g.arule(s.EQUALS, s.String).optional()._as(u'value'), s.EOL, s.Documentation.optional()._as(u'documentation'))
	function(g, u'Getter', s.ogetter)
	function(g, u'Setter', s.osetter)
	abstractFunction(g, u'AbstractMethod', s.omethod)
	abstractFunction(g, u'AbstractClassMethod', s.ooperation)
	function(g, u'Function', s.ofunction)
	function(g, u'Constructor', s.oconstructor, True)
	function(g, u'Method', s.omethod)
	function(g, u'ClassMethod', s.ooperation)
	g.rule(u'Parents', s.COLON, listOf(s.FQName, s.COMMA, g)._as(u'parents'))
	g.rule(u'EmbedLine', s.CheckIndent, s.EMBED_LINE, s.EOL)
	g.rule(u'Embed', s.BlockStart, s.oembed, g.arule(s.SPACE, s.NAME).optional()._as(u'language'), s.EOL, s.Indent, s.EmbedLine.zeroOrMore()._as(u'body'), s.Dedent)
	s.Block.add(s.Embed)
	g.rule(u'ClassGroup')
	g.group(u'ClassMethods', s.ClassMethod, s.AbstractClassMethod, s.Method, s.AbstractMethod, s.ClassGroup, s.Comment)
	s.ClassGroup.set(s.CheckIndent, s.ogroup, s.NAME._as(u'name'), s.EOL, s.Documentation.optional()._as(u'doc'), s.Indent, s.ClassMethods.zeroOrMore()._as(u'body'), s.Dedent)
	g.rule(u'InstanceGroup')
	g.group(u'InstanceMethods', s.Method, s.AbstractMethod, s.InstanceGroup, s.Comment)
	s.InstanceGroup.set(s.CheckIndent, s.ogroup, s.NAME._as(u'name'), s.EOL, s.Documentation.optional()._as(u'doc'), s.Indent, s.InstanceMethods.zeroOrMore()._as(u'body'), s.Dedent)
	g.rule(u'ModuleGroup')
	s.ModuleGroup.set(s.CheckIndent, s.ogroup, s.NAME._as(u'name'), s.EOL, s.Documentation.optional()._as(u'doc'), s.Indent, g.agroup(s.Function).zeroOrMore()._as(u'body'), s.Dedent)
	construct(g, u'Class', s.oclass, g.agroup(s.ClassAttribute, s.Attribute, s.Event, s.Getter, s.Setter, s.Constructor, s.ClassMethods))
	construct(g, u'Trait', s.otrait, g.agroup(s.ClassAttribute, s.Attribute, s.Event, s.Getter, s.Setter, s.Constructor, s.ClassMethods))
	construct(g, u'Singleton', s.osingleton, g.agroup(s.Attribute, s.Event, s.Getter, s.Setter, s.Constructor, s.InstanceMethods))
	g.rule(u'TargetAnnotation', s.CheckIndent, s.otarget, s.NAME._as(u'name'), g.arule(s.COLON, s.VERSION).optional(), s.EOL)
	g.rule(u'ModuleAnnotation', s.CheckIndent, s.omodule, s.FQName._as(u'name'), s.EOL)
	g.rule(u'VersionAnnotation', s.CheckIndent, s.oversion, s.VERSION._as(u'version'), s.EOL)
	g.rule(u'FeatureAnnotation', s.CheckIndent, s.ofeature, s.NAME._as(u'name'), s.VALUE.optional()._as(u'value'), s.EOL)
	g.rule(u'ImportAlias', s._as, s.NAME)
	g.rule(u'ImportSymbol', s.FQNAME, s.ImportAlias.optional())
	g.rule(u'ImportOrigin', s._from, s.FQNAME)
	g.rule(u'Import', s.CheckIndent, s.oimport, s.ImportSymbol._as(u'name'), g.arule(s.COMMA, s.ImportSymbol).zeroOrMore()._as(u'names'), s.ImportOrigin.optional()._as(u'origin'), s.EOL)
	g.rule(u'ModuleDeclaration', s.EmptyLines.zeroOrMore(), s.Comment.zeroOrMore()._as(u'comments'), s.TargetAnnotation.optional()._as(u'target'), s.FeatureAnnotation.zeroOrMore()._as(u'features'), s.ModuleAnnotation.optional()._as(u'module'), s.VersionAnnotation.optional()._as(u'version'), s.Documentation.optional()._as(u'documentation'), s.Import.zeroOrMore()._as(u'imports'))
	g.group(u'Structure', s.EmptyLines, s.Comment, s.ModuleAttribute, s.Type, s.Enum, s.ModuleGroup, s.Function, s.Class, s.Trait, s.Singleton)
	g.rule(u'Module', s.ModuleDeclaration, s.Structure.zeroOrMore()._as(u'structure'), s.Code.zeroOrMore()._as(u'code'), s.OWhere.zeroOrMore()._as(u'where'))
	s.OExampleBody.set(s.Module)
	g.skip = g.agroup(s.SPACE)
	g.axiom = s.Module
	return g


