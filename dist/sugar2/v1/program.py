#8< ---[sugar2/v1/program.py]---
#!/usr/bin/env python
# encoding: utf-8
import sys
__module__ = sys.modules[__name__]
from sugar2.helpers import doIndent, doCheckIndent, doDedent, doBlockStart, doBlockLastSetLine, doBlockLastSetBody, doBlockLastIsLine
import libparsing
__module_name__ = 'sugar2.v1.program'
G = None
def declaration (grammar, name, prefix):
	self=__module__
	g=grammar
	s=g.symbols
	return g.rule(name, s.CheckIndent, prefix, s.NameType._as(u'name'), g.arule(g.aword(u'='), s.Expression).optional()._as(u'value'), s.EOL, s.Documentation.optional()._as(u'documentation'))


def function (grammar, name, prefix, anonymous=None):
	self=__module__
	if anonymous is None: anonymous = False
	g=grammar
	s=grammar.symbols
	if anonymous:
		return g.rule(name, s.CheckIndent, prefix._as(u'type'), s.NOTHING._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'), s.Body._as(u'body'), s.OEnd)
	elif True:
		return g.rule(name, s.CheckIndent, prefix._as(u'type'), s.NameType._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'), s.Body._as(u'body'), s.OEnd)


def abstractFunction (grammar, name, prefix):
	self=__module__
	g=grammar
	s=grammar.symbols
	return g.rule(name, s.CheckIndent, s.oabstract, prefix._as(u'type'), s.NameType._as(u'name'), g.agroup(s.EOL, g.arule(s.ParameterList.optional(), s.EOL))._as(u'parameters'), s.Decorator.zeroOrMore()._as(u'decorators'), s.Documentation.optional()._as(u'documentation'))


def listOf (rule, separator, grammar):
	""" Creates a new list of the given rule, separated by the given separator
	 in the given grammar"""
	self=__module__
	return grammar.arule(grammar.arule(rule, separator).zeroOrMore(), rule)


def createProgramGrammar (g=None):
	self=__module__
	if g is None: g = libparsing.Grammar(u'Sugar')
	s=g.symbols
	g.token(u'SPACE', u'[ ]+')
	g.token(u'TABS', u'\t*')
	g.token(u'EMPTY_LINES', u'([ \t]*\n)+')
	g.token(u'COMMENT', u'[ \t]*\\#[^\n]*')
	g.token(u'EOL', u'[ ]*\n(\\s*\n)*')
	g.token(u'NUMBER', u'\\-?(([0-9]+(\\.[0-9]+)?)|(0x[A-Fa-f0-9]+)|(0b[01]+)|(0o[0-8]+))')
	g.token(u'FLOAT', u'\\-?[0-9]+(\\.[0-9]+)?')
	g.token(u'TIME', u'[0-9]+(\\.[0-9]+)?(ms|s|m|h|d|w)')
	g.token(u'NAME', u'(\\\\?)([\\$_A-Za-z][_\\w]*)')
	g.token(u'FQNAME', u'(\\\\?)([\\$_A-Za-z][\\._\\w]*)')
	g.token(u'KEY', u'[\\$_\\-A-Za-z][_\\-\\w]*')
	g.token(u'INFIX_OPERATOR', u'([\\-\\+\\*\\/\\%]|\\<=|\\>=|\\<\\<?|\\>\\>?|==|\\!=|\\.\\.|‥|\\|\\||&&|not\\s+in\\s+|in\\s+|and\\s+|or\\s+|is\\s+not\\s+|is\\s+|\\*\\*)')
	g.token(u'PREFIX_OPERATOR', u'(not\\s+|\\-)')
	g.token(u'NEW_OPERATOR', u'new\\s+')
	g.token(u'THROW_OPERATOR', u'raise|throw')
	g.token(u'ASSIGN_OPERATOR', u'[\\?\\*\\+\\-\\/\\%]?=')
	g.token(u'SYMBOLIC', u'None|Undefined|Nothing|Timeout')
	g.token(u'STRING_SQ', u"'(\\\\'|[^'\\n])*'")
	g.token(u'STRING_DQ', u'"(\\\\"|[^"\\n])*"')
	g.token(u'DOCSTRING', u'\\|[^\n]*')
	g.token(u'EMBED_LINE', u'\\|([^\n]*)')
	g.token(u'VERSION', u'[0-9]+(\\.[0-9]+)?(\\.[0-9]+)?[a-zA-Z_]*')
	g.token(u'DOT_OR_SPACE', u'\\.|[ \t]+')
	g.token(u'ITERATOR', u'::[\\?=\\<\\>]?')
	g.token(u'ELLIPSIS', u'\\.\\.\\.|‥')
	g.token(u'ARROW', u'\\-\\>|→')
	g.word(u'LP', u'(')
	g.word(u'RP', u')')
	g.word(u'LB', u'{')
	g.word(u'RB', u'}')
	g.word(u'LSB', u'[')
	g.word(u'RSB', u']')
	g.word(u'COMMA', u',')
	g.word(u'DOT', u'.')
	g.word(u'COLON', u':')
	g.word(u'SEMICOLON', u';')
	g.word(u'PIPE', u'|')
	g.word(u'EQUALS', u'=')
	g.word(u'STAR', u'*')
	g.condition(u'NOTHING')
	g.word(u'_var', u'var')
	g.word(u'_let', u'let')
	g.word(u'_if', u'if')
	g.word(u'_elif', u'elif')
	g.word(u'_else', u'else')
	g.word(u'_for', u'for')
	g.word(u'_while', u'while')
	g.word(u'_end', u'end')
	g.word(u'_in', u'in')
	g.word(u'_from', u'from')
	g.word(u'_as', u'as')
	g.word(u'_try', u'try')
	g.word(u'_catch', u'catch')
	g.word(u'_finally', u'finally')
	g.word(u'oabstract', u'@abstract')
	g.word(u'oimport', u'@import')
	g.word(u'omodule', u'@module')
	g.word(u'oversion', u'@version')
	g.word(u'ofunction', u'@function')
	g.word(u'oclass', u'@class')
	g.word(u'oprotocol', u'@protocol')
	g.word(u'oproperty', u'@property')
	g.word(u'oshared', u'@shared')
	g.word(u'ooperation', u'@operation')
	g.word(u'oconstructor', u'@constructor')
	g.word(u'omethod', u'@method')
	g.word(u'ogroup', u'@group')
	g.word(u'oend', u'@end')
	g.word(u'oembed', u'@embed')
	g.word(u'owhen', u'@when')
	g.procedure(u'Indent', doIndent)
	g.procedure(u'Dedent', doDedent)
	g.rule(u'CheckIndent', s.TABS._as(u'tabs'), g.acondition(doCheckIndent))
	g.rule(u'Comment', s.COMMENT._as(u'text'), s.EOL)
	g.rule(u'EmptyLines', s.EMPTY_LINES)
	g.rule(u'DocumentationLine', s.CheckIndent, s.DOCSTRING, s.EOL)
	g.rule(u'Documentation', s.DocumentationLine.oneOrMore())
	g.group(u'String', s.STRING_SQ, s.STRING_DQ)
	g.rule(u'Expression')
	g.group(u'Number', s.TIME, s.NUMBER)
	g.group(u'Key', s.KEY, s.Number, s.String, g.arule(s.LP, s.Expression, s.RP))
	g.rule(u'KeyValue', s.Key, s.COLON, s.Expression)
	g.rule(u'ImplicitKey', s.KEY)
	g.group(u'Entry', s.KeyValue, s.ImplicitKey)
	g.rule(u'EntryList', s.Entry, g.arule(s.COMMA, s.Entry).zeroOrMore())
	g.rule(u'ExpressionList', s.Expression, g.arule(s.COMMA, s.Expression).zeroOrMore())
	g.rule(u'ExpressionBlock', s.Indent, g.arule(s.EOL, s.CheckIndent, s.ExpressionList).oneOrMore(), s.Dedent)
	g.rule(u'EntryBlock', s.Indent, g.arule(s.EOL, s.CheckIndent, s.EntryList).oneOrMore(), s.Dedent)
	g.rule(u'Array', s.LSB, s.ExpressionList.optional()._as(u'head'), s.ExpressionBlock.optional()._as(u'tail'), g.arule(s.EOL, s.CheckIndent).optional(), s.RSB)
	g.rule(u'Map', s.LB, s.EntryList.optional()._as(u'head'), s.EntryBlock.optional()._as(u'tail'), g.arule(s.EOL, s.CheckIndent).optional(), s.RB)
	g.rule(u'TypeStructure', g.atoken(u'\\<[^\\>]*\\>'))
	g.rule(u'Type', g.agroup(s.NAME, s.TypeStructure))
	g.rule(u'NameType', s.NAME, g.arule(s.COLON, s.Type).optional())
	g.rule(u'FQName', s.NAME, g.arule(s.DOT_OR_SPACE, s.NAME).zeroOrMore())
	g.rule(u'Parameter', s.NameType._as(u'name'), g.arule(s.EQUALS, s.Expression).optional()._as(u'value'))
	g.rule(u'ParameterList', s.Parameter, g.arule(s.COMMA, s.Parameter).zeroOrMore(), s.ELLIPSIS.optional())
	g.rule(u'SymbolList', s.NAME, g.arule(s.COMMA, s.NAME).zeroOrMore(), s.ELLIPSIS.optional())
	g.rule(u'ArgumentsEmpty', s.LP, s.RP)
	g.rule(u'ArgumentsMany', s.LP, s.ExpressionList.optional()._as(u'line'), s.ExpressionBlock.optional()._as(u'body'), g.agroup(s.RP, g.arule(s.EOL.optional(), s.CheckIndent, s.RP)))
	g.rule(u'ClosureStatement')
	g.rule(u'ClosureLine', s.EOL, s.CheckIndent, g.agroup(s.COMMENT, s.ClosureStatement))
	g.rule(u'ClosureParameters', s.ParameterList.optional(), s.PIPE)
	g.rule(u'EmptyClosure', s.LB, s.ClosureParameters, s.RB)
	g.rule(u'InlineClosure', s.LB, s.ClosureParameters.optional(), s.ClosureStatement, s.RB)
	g.rule(u'BlockClosure', s.LB, s.ClosureParameters.optional(), s.Indent, s.ClosureLine.zeroOrMore(), s.EOL, s.Dedent, s.CheckIndent, s.RB)
	g.group(u'Closure', s.BlockClosure, s.InlineClosure, s.EmptyClosure)
	g.group(u'Literal', s.Number, s.SYMBOLIC, s.String, s.Array, s.Map, s.Closure)
	g.rule(u'Reference', s.NAME, g.arule(s.DOT, s.NAME).zeroOrMore())
	g.rule(u'Decomposition', s.DOT_OR_SPACE, s.Reference)
	g.rule(u'ComputationInfix', s.INFIX_OPERATOR, s.Expression)
	g.rule(u'Access', s.LSB, s.Expression, s.RSB)
	g.rule(u'Slice', s.LSB, s.Expression.optional(), s.COLON, s.Expression.optional(), s.RSB)
	g.group(u'Invocation', s.Literal, s.ArgumentsEmpty, s.ArgumentsMany)
	g.rule(u'Parentheses', s.LP, s.Expression, s.RP)
	g.group(u'Suffixes')
	g.rule(u'ChainLine', s.EOL, s.Indent, s.CheckIndent, g.agroup(s.COMMENT, s.Reference, s.Suffixes).oneOrMore(), s.Dedent)
	g.rule(u'Chain', s.COLON, s.ChainLine.oneOrMore())
	g.rule(u'ConditionalExpression', s._if, s.Expression._as(u'condition'), s.ARROW, s.Expression._as(u'true'), s.PIPE, s.Expression._as(u'false'))
	g.rule(u'IterationSuffix', s.ITERATOR._as(u'op'), s.Expression._as(u'rvalue'))
	g.group(u'Prefixes', s.Literal, g.rule(u'Exception', s.THROW_OPERATOR, s.SPACE, s.Expression._as(u'expression')), g.rule(u'Instanciation', s.NEW_OPERATOR, g.agroup(s.FQName, s.Parentheses)._as(u'target'), s.Invocation._as(u'params')), g.rule(u'ComputationPrefix', s.PREFIX_OPERATOR, s.Expression), s.ConditionalExpression, s.NAME, s.Parentheses)
	s.Suffixes.set(s.Chain, s.IterationSuffix, s.ComputationInfix, s.Decomposition, s.Access, s.Slice, s.Invocation)
	s.Expression.set(s.Prefixes, s.Suffixes.zeroOrMore())
	g.rule(u'Assignable', s.NAME, g.agroup(s.Decomposition, s.Access, s.Slice, s.Invocation).zeroOrMore())
	g.rule(u'Allocation', g.agroup(s._var, s._let), s.SPACE, s.SymbolList._as(u'symbols'), g.arule(s.PIPE, s.NAME).optional()._as(u'rest'), g.arule(s.EQUALS, s.Expression).optional()._as(u'value'))
	g.rule(u'Assignment', g.arule(s.Assignable, s.COMMA).zeroOrMore()._as(u'before'), s.Assignable._as(u'main'), g.arule(s.PIPE, s.Assignable).optional()._as(u'rest'), g.arule(s.ASSIGN_OPERATOR, s.Expression)._as(u'op'))
	g.rule(u'Termination', g.aword(u'return'), s.Expression.optional())
	g.rule(u'Break', g.aword(u'break'))
	g.rule(u'Pass', g.aword(u'pass'))
	g.rule(u'Continue', g.aword(u'continue'))
	g.group(u'Block')
	g.group(u'Code')
	g.group(u'Statement', s.Comment, s.Block, s.Allocation, s.Assignment, s.Termination, s.Break, s.Continue, s.Pass, s.Expression)
	g.rule(u'Statements', s.Statement, g.arule(s.SEMICOLON, s.Statement).zeroOrMore())
	g.rule(u'Line', s.CheckIndent, s.Statements.optional(), s.COMMENT.optional(), s.EOL)
	g.procedure(u'BlockStart', doBlockStart)
	g.rule(u'BlockLine', s.ARROW, s.Statements._as(u'body'), s.COMMENT.optional())
	g.rule(u'BlockBody', s.EOL, s.Indent, s.Code.zeroOrMore()._as(u'body'), s.Dedent)
	g.group(u'BlockEnd', g.arule(s.CheckIndent, s._end))
	g.rule(u'IfLine', s._if, s.Expression._as(u'condition'), g.agroup(s.BlockLine)._as(u'body'))
	g.rule(u'ElifLine', s.EOL, s.CheckIndent, s._elif, s.Expression._as(u'condition'), g.agroup(s.BlockLine)._as(u'body'))
	g.rule(u'ElseLine', s.EOL, s.CheckIndent, s._else, g.agroup(s.BlockLine)._as(u'body'))
	g.rule(u'IfBlock', s._if, s.Expression._as(u'condition'), g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'ElifBlock', s.CheckIndent, s._elif, s.Expression._as(u'condition'), g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'ElseBlock', s.CheckIndent, s._else, g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'WhileBlock', s._while, s.Expression._as(u'condition'), g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'TryBlock', s._try, g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'FinallyBlock', s.CheckIndent, s._finally, g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'CatchBlock', s.CheckIndent, s._catch, s.NameType.optional()._as(u'param'), g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'ForBlock', s._for, s.ParameterList._as(u'params'), s._in, s.Expression._as(u'expr'), g.agroup(s.BlockBody, s.BlockLine)._as(u'body'))
	g.rule(u'ConditionalLine', s.IfLine._as(u'if'), s.ElifLine.zeroOrMore()._as(u'elif'), s.ElseLine.optional()._as(u'else'))
	g.rule(u'ConditionalBlock', s.BlockStart, s.IfBlock._as(u'if'), s.ElifBlock.zeroOrMore()._as(u'elif'), s.ElseBlock.optional()._as(u'else'), s.BlockEnd)
	g.group(u'Conditional', s.ConditionalLine, s.ConditionalBlock)
	g.rule(u'Try', s.BlockStart, s.TryBlock._as(u'try'), s.CatchBlock.optional()._as(u'catch'), s.FinallyBlock.optional()._as(u'finally'), s.BlockEnd)
	g.rule(u'Repetition', s.BlockStart, s.WhileBlock._as(u'while'), s.BlockEnd)
	g.rule(u'Iteration', s.BlockStart, s.ForBlock._as(u'for'), s.BlockEnd)
	s.Block.set(s.Conditional, s.Repetition, s.Iteration, s.Try)
	s.Code.set(s.Comment, s.Block, s.Line)
	g.rule(u'OEnd', s.CheckIndent, s.oend, s.EOL)
	g.rule(u'Body', s.Indent, s.Code.zeroOrMore()._as(u'code'), s.Dedent)
	g.rule(u'OWhen', s.CheckIndent, s.owhen, s.Expression._as(u'expression'), s.EOL)
	g.group(u'Decorator', s.OWhen)
	s.ClosureStatement.set(s.Statements)
	declaration(g, u'ClassAttribute', s.oshared)
	declaration(g, u'ModuleAttribute', s.oshared)
	declaration(g, u'Attribute', s.oproperty)
	abstractFunction(g, u'AbstractMethod', s.omethod)
	abstractFunction(g, u'AbstractClassMethod', s.ooperation)
	function(g, u'Function', s.ofunction)
	function(g, u'Constructor', s.oconstructor, True)
	function(g, u'Method', s.omethod)
	function(g, u'ClassMethod', s.ooperation)
	g.rule(u'CGroup')
	g.group(u'Methods', s.ClassMethod, s.AbstractClassMethod, s.Method, s.AbstractMethod, s.AbstractMethod, s.CGroup, s.Comment)
	s.CGroup.set(s.CheckIndent, s.ogroup, s.NAME._as(u'name'), s.EOL, s.Documentation.optional(), s.Indent, s.Methods.zeroOrMore()._as(u'methods'), s.Dedent, s.OEnd)
	g.rule(u'EmbedLine', s.CheckIndent, s.EMBED_LINE, s.EOL)
	g.rule(u'Embed', s.oembed, s.SPACE, s.NAME.optional()._as(u'language'), s.EOL, s.EmbedLine.zeroOrMore()._as(u'body'), g.arule(s.CheckIndent, s.oend))
	s.Block.add(s.Embed)
	g.rule(u'Class', s.oabstract.optional(), s.oclass, s.NAME._as(u'name'), g.arule(s.COLON, listOf(s.FQName, s.COMMA, g)).optional()._as(u'inherits'), s.EOL, s.Documentation.optional()._as(u'documentation'), s.Indent, g.agroup(s.ClassAttribute, s.Attribute, s.ClassMethod, s.AbstractMethod, s.Constructor, s.Methods).zeroOrMore()._as(u'body'), s.Dedent, g.aword(u'@end'))
	g.rule(u'Interface', s.oprotocol, s.NAME._as(u'name'), g.arule(s.COLON, listOf(s.FQName, s.COMMA, g)).optional()._as(u'inherits'), s.EOL, s.Documentation.optional()._as(u'documentation'), s.Indent, g.agroup(s.ClassAttribute, s.Attribute, s.ClassMethod, s.AbstractMethod, s.Constructor, s.Methods).zeroOrMore()._as(u'body'), s.Dedent, g.aword(u'@end'))
	g.rule(u'ModuleAnnotation', s.omodule, s.FQName, s.EOL)
	g.rule(u'VersionAnnotation', s.oversion, s.VERSION, s.EOL)
	g.rule(u'ImportAlias', s._as, s.NAME)
	g.rule(u'ImportSymbol', g.agroup(s.FQNAME, s.STAR), s.ImportAlias.optional())
	g.rule(u'ImportOrigin', s._from, s.FQNAME)
	g.rule(u'Import', s.oimport, s.ImportSymbol, g.arule(s.COMMA, s.ImportSymbol).zeroOrMore(), s.ImportOrigin.optional(), s.EOL)
	g.rule(u'ModuleDeclaration', s.EmptyLines.zeroOrMore(), s.Comment.zeroOrMore()._as(u'comments'), s.ModuleAnnotation.optional()._as(u'module'), s.VersionAnnotation.optional()._as(u'version'), s.Documentation.optional()._as(u'documentation'), s.Import.zeroOrMore()._as(u'imports'))
	g.group(u'Structure', s.EmptyLines, s.Comment, s.ModuleAttribute, s.Function, s.Class, s.Interface)
	g.rule(u'Module', s.ModuleDeclaration, s.Structure.zeroOrMore(), s.Code.zeroOrMore())
	g.skip = g.agroup(s.SPACE)
	g.axiom = s.Module
	return g


